ckpd  Program:

ckpd    triangle.for

ckpd  Purpose:

ckpd    ATCF end users are forecasters of tropical cyclones. This
ckpd    responsibility includes forecasts of storm future positions and
ckpd    intensities.

ckpd    In doing the forecasting task, ATCF end users make use of
ckpd    forecasting aids generated by large mainframe computers from
ckpd    meteorological models.  Because these forecasting aids derive
ckpd    their forecasts of future storm behavior with little human
ckpd    interaction during the computers' model manipulations, these
ckpd    forecasting aids are styled "objective aids".

ckpd    There are several (over four dozen at the present writing)
ckpd    objective aids available to the forecaster. Forecasting is done
ckpd    on an Area Of Responsibility (AOR) basis, and the large areas of
ckpd    the world which constitute a separately assignable AOR are
ckpd    called "basins".  Many objective aids are restricted in
ckpd    applicability to one or a few basins.

ckpd    ATCF end users forecast storm behavior well in advance. The
ckpd    standard time of publication of the forecast is called a
ckpd    synoptic time. By world wide convention, the synoptic times are
ckpd    the even six hour Greenwich Mean Times 00:00:00, 06:00:00,
ckpd    12:00:00, and 18:00:00 "zulu".

ckpd    Storm behavior is forecast (and published as "warning" messages)
ckpd    from the present synoptic time, and for future synoptic times.
ckpd    For the purposes of this program, these future times are
ckpd    currently 00, 12, 24, 36, 48, and 72 hours from the forecast's
ckpd    synoptic publication time.      These intervals are usually
ckpd    spoken of within this community as "tau 00", "tau +12", ..., and
ckpd    "tau +72".

ckpd    It is of interest to compare the success of the ATCF end user
ckpd    forecasters' predictions of storm behavior both absolutely, and
ckpd    in comparision to the objective aids' predictions of storm
ckpd    behavior. It is also of interest to measure the success of the
ckpd    various objective aids both absolutely and in comparisions
ckpd    against one another.

ckpd    Success is measured as smallness of "average" forecast error,
ckpd    where "average" can mean one of several available statistics
ckpd    measuring central value.

ckpd    What is used in these evaluations is the error of the forecast
ckpd    at a "tau" measured against what the storm actually did (or
ckpd    better, where the storm actually was) at that tau, in
ckpd    retrospect.

ckpd    To have an error, one must first have something with which to
ckpd    disagree so as to be in error.  Errors for this program are
ckpd    developed by another program (ddeck.for) as a measure against
ckpd    the storm's "best track" positions.

ckpd    Best track positions are estimates of the central position of
ckpd    the storm mass at each synoptic time. Although tropical cyclones
ckpd    have a prominent "eye" that might seem an ideal measure of the
ckpd    location of the storm's center, in physical fact the eye
ckpd    wobbles, or more properly nutates, about the center of mass of
ckpd    the tropical cyclone as a whole.

ckpd    Since it is the body of the tropical cyclone as a whole which
ckpd    does damage, not just the eye, so it is the body of the tropical
ckpd    cyclone whose overall motion is of interest to forecast, and it
ckpd    is the motion of the body of the the storm overall which is
ckpd    desired as a truth against which to measure forecast errors.

ckpd    The body motion of a storm is captured as a "best track" in
ckpd    three qualities.

ckpd    The "objective best track" is a curve faired by the ATCF
ckpd    workstation computer through the fix positions and times for the
ckpd    storm.  This is a somewhat smoothed estimate of the eye motion,
ckpd    since it the location of the storm eye which is the subject of
ckpd    fix information, but the line generated tries to make a smooth
ckpd    path among these fixes.

ckpd    Next better is the "working best track", which is usually
ckpd    created starting with the objective best track, lending more or
ckpd    less credance to particular fixes based on their reliability and
ckpd    agreement with the rest of the fix information, and moving storm
ckpd    estimated positions to make a smoother path that more closely
ckpd    estimates the storm's bulk motion.

ckpd    Best quality is the "final best track".  This is created after
ckpd    the storm has ended, when the pressure of publishing warning
ckpd    messages yo meet a radio traffic deadline is gone, and the time
ckpd    is available for the forecaster to evaluate more closely all
ckpd    available information about the storm's motion during its
ckpd    lifetime.

ckpd    Which of these best tracks is used as "truth" against which
ckpd    ddeck.for measures errors depends on which is available when
ckpd    that program is run.  In whatever case, ddeck.for captures both
ckpd    objective aids forecasts and best track positions to generate a
ckpd    large file of errors, forecast tau by forecast tau, for all the
ckpd    aids that did a forecast for that storm for that tau.

ckpd    This program is tasked to accumulate these errors, perform
ckpd    various statistical analyses of the absolute and comparitive
ckpd    average errors, and present the results as a series of "triangle
ckpd    tables" with the aids on each axis, and their results against
ckpd    themselves("absolute success"), and also against the other aids
ckpd    with which they made forecasts in common ("comparitive
ckpd    success"), displayed.

ckpd  Inputs:

ckpd    A variously named file, usually called techlist.dat, whose name
ckpd    is he first parameter of the command line that executes this
ckpd    program.

ckpd    This file is a forecasting aids control table, shared by many
ckpd    ATCF 2.7x programs, that is instantiated once for each basin.
ckpd    Forecasting "objective" aids are mostly the outputs of
ckpd    meteorological modelling programs that predict a storm's path or
ckpd    intensity or both.  Mixed in with these are a few records of
ckpd    human forecasting, at least the CARQ, WRNG, and JTWC aids, used
ckpd    in post facto forecasting error analysis.

ckpd    The first line of the table is a header line and is skipped.
ckpd    Each successive line holds a forecasting objective aids' two
ckpd    integer ID code, its four character ASCII nickname, a flag that
ckpd    shows whether the aid is requested by the forecaster for
ckpd    forecasting storms in the current basin, a flag that shows
ckpd    whether the aid is used in computing the various error
ckpd    estimating statistics with which at least the current program
ckpd    and one of its feeder programs, ddeck.for, are involved, and an
ckpd    integer color code that identifies how the aid should be
ckpd    displayed on the forecaster's workstation.

ckpd    triangle.in, a mixed file of control codes for this program
ckpd    only, that show for what error types statistics should be
ckpd    computed, for what statistic types triangles should be written
ckpd    for each error type, and whether a diagnostic trace of program
ckpd    execution should be written to an output diagnostic file by this
ckpd    program.

ckpd    The data file of forecasting errors for which triangle tables
ckpd    are to be generated.

ckpd    This is a variously named file (usually called d<storm-id>.dat
ckpd    or dcombo.dat) of one storm's forecast errors data in the former
ckpd    case, or of a basin & season's worth of storm forecast errors
ckpd    data in the latter case, in either case as written by the
ckpd    executable version of ddeck.for.

ckpd    The file name is read from the second parameter of the command
ckpd    line that executes this program.

ckpd    These "errors" are created by comparing the forecast positions
ckpd    and intensities against the subsequently developed "best track"
ckpd    of storm motion and intensity, which itself comes in three
ckpd    flavors.  The "objective best track" is a computer fitted curve
ckpd    through the fix information. The "working best track" is created
ckpd    by the forecaster, usually starting from the objective best
ckpd    track, and modifying it for both current and past positions,
ckpd    during the forecast process.  The "smooth best track" is created
ckpd    in a post-storm, usually post-season, operation to provide the
ckpd    best possible estimate of the motion of the storm as a whole,
ckpd    damping out the nutations of the central cyclone "eye".

ckpd    Note that this program runs in about 80% of the normal "from
ckpd    hard disk" run time if this input file is being read from a RAM
ckpd    disk, on a 16 megahertz 80386 platform, and proportionally even
ckpd    faster on a machine with a faster CPU.  This is because this
ckpd    input file is traversed once for each combination of error type
ckpd    and statistic type requested to be written for publication as a
ckpd    set of triangle tables.

ckpd  Outputs:

ckpd    triangle.out, a detailed diagnostic trace of this program's
ckpd    execution.

ckpd    A variously named (usually d<storm-id>.tri or dcombo.tri) file
ckpd    of the printable triangle table output from this program.  The
ckpd    name of this file is the third parameter on the command line
ckpd    that executes this program.

ckpd    Various screen warning messages and progress reports. [This
ckpd    program will take _lots_ of time to finish on a fairly fast
ckpd    MS-DOS platform, because it traverses the input data multiple
ckpd    times to compute and write triangle tables for multiple
ckpd    forecasting error types and multiple statistics types.  This is
ckpd    in turn due to the limitations of MS-DOS and the Fortran
ckpd    compiler used, which between them severely limit the ability to
ckpd    hold data in machine memory.]

ckpd  Author:

ckpd    Kent Paul Dolan, Computer Sciences Corporation contractor to
ckpd    Fleet Numerical Oceanography Center, Monterey, California,
ckpd    United States of America 93940-5005, phone (408) 656-4363
ckpd    keeping GMT - 7 office hours

ckpd  Conventions:

ckpd    To help keep this code maintainable, please adhere scruptulously
ckpd    to the following programming standards.

ckpd    Declare, with explicit type byte sizes, and explain every
ckpd    variable used in the program.  ATCF 2.7x maintenance has been
ckpd    rendered intensely tedious by bugs originating in undeclared
ckpd    integer variables passed as parameters, that had, due to
ckpd    metacommands and compiler control flags, different byte sizes in
ckpd    the calling and the called programs.

ckpd    Within the limits of Standard Fortran, wherever possible, use
ckpd    meaningful variable names, not merely "I", "J" or "K" for
ckpd    indices, for example, but "ISTAT", "JSYNOP", "KTAU" to show what
ckpd    is attribute is being varied as an index, so that the meaning of
ckpd    code is clear in the local context, rather than requiring a
ckpd    complete analysis of the whole program.

ckpd    Comment each line, even an "endif", with a remark that tells
ckpd    your intent for that code.  This makes it much easier for
ckpd    someone who doesn't understand either the math or the
ckpd    application to correct errors in your code.

ckpd    Code commented out or comments describing code should use, in
ckpd    lowercase for ease of reading, an identifying tag consisting of
ckpd    the letter "c" followed by the programmer's initials.
ckpd    Substantive additional functionality or functionality changes
ckpd    due to changes in the format of the input data should be, in
ckpd    addition, commented each place a change is made to include the
ckpd    title and date of the change, and the superseded code left
ckpd    intact but commented out, so that there is a capability to
ckpd    retrofit the code in the (very frequent) instance that data in
ckpd    the old format is discovered and must be processed.

ckpd    Places where the maintainer suspects bugs or the need for future
ckpd    maintenance should be marked with comment lines lines beginning
ckpd    after the identifying tag with the keyword "fixme" in all
ckpd    uppercase letters, followed by two spaces, so that the comments
ckpd    can be pulled out into a report by use of a string parsing
ckpd    routine of the "grep" family.  In almost every case, these
ckpd    comments should have some code context with them so that the
ckpd    report makes sense without referring back to the source code
ckpd    file. These comments should have the keywords "fixme context"
ckpd    (to differentiate them from other commented out code, while
ckpd    still letting a grep for uppercase "fixme" find them) in all
ckpd    uppercase after the identifying tag and before the code being
ckpd    included for context.

ckpd    To make the report, which will consist with the present "grep"
ckpd    tools of a file name alone on a line followed by a series of
ckpd    source code lines each preceded by a line number requiring eight
ckpd    dedicated character positions to display, source code file
ckpd    comments and code should be obsessively limited to the first 72
ckpd    character positions of each line. This will in most cases
ckpd    require that the code after the "fixme context" be reformatted
ckpd    to fit on shorter lines by the use of continuation lines.  This
ckpd    sounds like a lot of work, but is well worth the effort, and can
ckpd    be accomplished fairly painlessly with intelligent use of text
ckpd    editor macro commands.

ckpd    Once your code is instrumented with such "fixme" comments, it
ckpd    becomes much easier to find bugs suspected but not proven, or to
ckpd    pick the next most crucial maintenance item awaiting effort, by
ckpd    simply creating such a report automatically and reading it for
ckpd    hints from prior toilers of where the current crises level
ckpd    problem might lie.  Thus, limitations that the maintainer knows
ckpd    might be exceeded by later operational needs should be commented
ckpd    with "fixme" remarks, even though the code as written works
ckpd    correctly in the current operational context, to ease later
ckpd    maintenance.

ckpd  History:

ckpd    Begun 06 January 1993 as an analyze, redesign,  cut and paste
ckpd    effort using the existing ATCF 2.7x triang.for source code as a
ckpd    working example from which to reverse engineer pseudo code, and
ckpd    for inspiration a modified but badly mangled version written by
ckpd    Mike Fiorino, also from triang.for as a starting point.  This
ckpd    code, called mftri10.for,  was written by him for use of the
ckpd    Joint Typhoon Warning Center, Guam, USA.  It added to triang.for
ckpd    an input control file capability to cut down repetitive user
ckpd    interactions, successfully. It also added an attempt to speed up
ckpd    and correct the gamma median processing, unsuccessfully because
ckpd    that change introduced far more bugs than it cured.  Mike's
ckpd    mftri10.for program was shredded out to make lots of independent
ckpd    subroutine source files, so that maintenance could be done
ckpd    quickly, using make files and only recompiling modified code
ckpd    rather than the whole 8 or 9 hundred lines of Mike's mftri10.for
ckpd    main routine as discovered.


c     Record of changes:
c
cx      Modified 4/15/96   sampson, nrl    modified to work in Unix
cx                                         with ATCF 3.0
c
c       Modified 7/98   A. Schrader, SAIC  modified to use new data
c                                          format
c       Modified 12/98  A. Schrader, SAIC  modified to add forecast
c                                          periods, TAU 96 and 120
c
ckpd  Program Header:

cx      program triang

ckpd  --------------------- parameterize program -----------------------

      include 'triparms.inc'

ckpd  ------------------- declare variables and data -------------------

ckpd  Variable and Predefined Data Declarations:

      include 'tridecls.inc'

cF    if (iodiag)
cF   &  write(*,'('' Entering triang()'')')

ckpd  --------------------------- open files ---------------------------

ckpd  Open control, technique list, input data, output diagnostic trace,
ckpd  and output result files.

      call opfils(iodiag)

ckpd  --------------- read program option control file -----------------

ckpd  Because I spelled out the full .false. and .true. in the control
ckpd  file, the "L" edit field needs more than one character to capture
ckpd  the "t" or "f" it is seeking.  Seven characters captures the whole
ckpd  ".false.", so specify that in case the rules ever change (the rule
ckpd  that the first "t" or "f" after optional spaces and an optional
ckpd  decimal point gives the value, that is).  This will hold in the
ckpd  called routines rerrf() and rstatf(), as well.

ckpd  Eat seven lines of header and comments from unit lucont.

      call eatlin(lucont,7,iodiag)

ckpd  Read in the control logical variable, that turns
ckpd  debug dumping to the diagnostic trace file on and off.

      read(lucont,'(L7)') iodiag

ckpd  Eat three lines of separator comments from unit lucont.

      call eatlin(lucont,3,iodiag)

ckpd  Get the enable / disable flags and the ASCII names for the
ckpd  requested types of forecast errors for which statistics are to be
ckpd  generated (up to eight different errors are currently available).

      call rerrf(lerror,iodiag)

ckpd  Eat four lines of separator comments from unit lucont.

      call eatlin(lucont,4,iodiag)

ckpd  Get requested statistic types (arithmetic mean of absolute values,
ckpd  standard deviation and Student's T of signed values, gamma median
ckpd  of signed values, arithmetic median of absolute values, and
ckpd  arthmetic median of signed values are the current choices).

ckpd  Read from the control file flags for the types of statistics to
ckpd  produce for each error type.

      call rstatf(lstats,iodiag)

ckpd  Eat four lines of separator comments from lucont.

      call eatlin(lucont,4,iodiag)

ckpd  Get enable / disable flag for writing a table of (CARQ and WRNG)
ckpd  positions errors' means and standard deviations against best track
ckpd  positions.

      read(lucont,'(L7)') lposit

ckpd  ---------- read objective aid technique control file -------------

ckpd  Get requested techniques (up to naids of taids) into the taids
ckpd  element static techniques arrays MTECH (integer) and ATECH
ckpd  (ascii), and get the number of them, NTUSED.

      call rdtech(atech,ltechs,ntused,iodiag)

ckpd  ---------------------- loop on error types -----------------------


ckpd  For each possible error type NER of the NKINDS of errors ...


      do 800 ner=1,nkinds

ckpd    If this error is requested for processing ...

        if (lerror(ner)) then

ckpd      For each possible statistic type ISTAT of NSTATS ...

ckpd  -------------------- loop on statistic types ---------------------

          do 790 istat=1,nstats

ckpd            If this statistic is requested for processing ...

            if (lstats(istat)) then

ckpd          rewind the input data file

              rewind luinpt

ckpd          Flag the input file as not yet exhausted; we'll need this
ckpd          later.

              indone = .false.


ckpd          Fill the dynamic technique array NTECH(type,tau) from the
ckpd          static technique arrays LTECHS (for control) and ATECH
ckpd          (for four character ASCII names of the forecasting aids
ckpd          contents) for each technique for all 5 possible taus.
ckpd          Repeated five times because this will later become a
ckpd          "ragged right" array when "no occurrences" columns and
ckpd          rows are tossed out for each tau separately and probably
ckpd          differently.

              call fntech(atech,ltechs,ntech,iodiag)

ckpd          Read the first input data cards until one with a storm id
ckpd          is found, store it in STORM, and back up one record so
ckpd          that the card will be the next one read.

              call stm1id(storm,indone,iodiag)

ckpd          Check for a lack of any useful data in the input data file.

              if (indone) then

cx              stop
cx   &            ' No valid storm numbers in input data file records.'
                print *,
     &             'No valid storm numbers in input data file records.'
                stop

              endif

ckpd          clear the triangle arrays TRI (integer) and TRI1 (real) to
ckpd          zeros

              call ctri(tri,iodiag)

              call ctri1(tri1,iodiag)

ckpd  ------------------------ loop on storms --------------------------

ckpd              For each storm in the input data ...

  100         continue

ckpd  If progress reporting is compile in, report the storm, statistic
ckpd  type, and error type as a progress report

cP    write(*,
cP   &  '(//,'' Status of triangle table run:'')')
cP    write(*,'(''   Stat type :  '',a38)') astats(istat)
cP    write(*,'(''   Error type:  '',a31)') aerr(ner)
cP    write(*,'(''   Storm name:  '',a6,)') storm

cD    write(ludiag,
cD   &  '(//,'' Status of triangle table run:'')')
cD    write(ludiag,'(''   Stat type :  '',a38)') astats(istat)
cD    write(ludiag,'(''   Error type:  '',a31)') aerr(ner)
cD    write(ludiag,'(''   Storm name:  '',a6,)') storm

ckpd  This is where the implementer can turn on data dumps restricted to a
ckpd  single storm.  Leave it around for debuggin later problems.
ckpd                if ((istat .eq. 2) .and. (storm .eq. 'WP2992')
ckpd     &            .and. (ner .eq. 1)) then
ckpd
ckpd                  iodiag = .true.
ckpd
ckpd                else
ckpd
ckpd                  iodiag = .false.
ckpd
ckpd                endif

ckpd            clear the first and last date variables FSTDY and LSTDY
ckpd            for this storm

                fstdy = '00000000'
                lstdy = '00000000'

ckpd            clear the whole ERROR array to "no data" values

                call cerror(error,iodiag)

ckpd  ------------------------ fill error table ------------------------

ckpd            Fill the ERROR array with values from a single storm,
ckpd            flagging a possible end of input in INDONE and a
ckpd            possible lack of useful data in LSTDY with an unchanged
ckpd            value.  We do this in two phases rather than just adding
ckpd            data directly into the triangle tables because the
ckpd            existance of "matching" values off of other data cards
ckpd            modifies what gets added into what triangle location,
ckpd            and array ERROR is where this check for matching values
ckpd            must happen.  Unfortunately, that makes the array quite
ckpd            large, since it must hold an entire storm full of data
ckpd            for one statistic type, one error type, and all selected
ckpd            forecast aid types.

ckpd  If progress reporting is compiled in, mark a progress step.

cP    write(*,'(''   Filling error table from disk storm data.'')')

                call ferror(ntech, stdtau, astats, error, storm, fstdy,
     &            lstdy, indone, istat, ntused, ner, iodiag)

cD              if (iodiag)
cD   &            write(*,'(1x,10i6,/,4x,10i6,/)')
cD   &            (((error(iaid,kerr,ktau)
cD   &            ,kerr=1,ner),ktau=1,ntau),iaid=1,ntused)

ckpd  --------------------- fill triangle tables -----------------------

ckpd            Fill the triangle tables TRI and TRI1 with values from
ckpd            array ERROR.  The exact method of adding in the error
ckpd            data is dependent on the statistic type and on whether
ckpd            the triangle table position is above the hypotenuse
ckpd            (ignored), on the hypotenuse (errors against self are
ckpd            accumulated for each forecast aid) or below the
ckpd            hypotenuse (errors against both self and other aids are
ckpd            accumulated for each forecast aid pair where a common
ckpd            forecast "event" (synoptic period base time and tau
ckpd            ordinal forecast time) is "matched" (both aids forecast
ckpd            for it) for both).

ckpd  If progress reporting is compiled in, mark a progress step.

cP    write(*,'(''   Accumulating error data to triangle tables.'')')

                call filtri(error,tri,tri1,fstdy,lstdy,istat,ntused,
     &            iodiag)

ckpd          End for each storm in the input data.

              if (.not. indone) goto 100

ckpd  ------------------- compress triangle tables ---------------------

ckpd          Not all forecast aids forecast for all NTAU possible tau
ckpd          offsets from the current synoptic period of the forecast;
ckpd          some do fewer.  Rather than publish tables full of lots of
ckpd          uninteresting values, for each KTAU among the current
ckpd          NTAU, _separately_ collapse the part of the TRI and TRI1
ckpd          tables corresponding to that tau KTAU, and store into
ckpd          NTOT(KTAU) the number of aids for which information
ckpd          remains that is interesting to print.  This not only saves
ckpd          us from printing drivel, it also saves lots of checks that
ckpd          some data exists in a location before further computations
ckpd          are done with it.  The details of collapsing the arrays
ckpd          are complex but uninteresting, and already work correctly
ckpd          in the existing code, which see.

ckpd  If progress reporting is compiled in, mark a progress step.

cP    write(*,
cP   &  '(''   Compressing "no data" triangle table rows & columns.'')')

              call remdud(ntot,tri,tri1,ntech,ntused,iodiag)

ckpd          The triangles are loaded and compressed for this error
ckpd          type and statistic type combination.  Now finish the
ckpd          computations needed for the triangle table computations.

ckpd  If progress reporting is compiled in, mark a progress step.

cP    write(*,
cP   &  '(''   Processing accumulated triangle data into printable'',
cP   &  '' statistics.'')')

              call cmptri(ntot,ntech,tri,tri1,istat,iodiag)

ckpd          The triangles are full of the final results, so print them
ckpd          out for the user.

ckpd  If progress reporting is compiled in, mark a progress step.

cP    write(*,
cP   &  '(''   Printing triangle tables to output file.'')')

              call prttri(ntot,ntech,tri,aerr,stdtau,ner,istat,iodiag)

ckpd        End if this statistic is requested for processing.

            endif

ckpd      End for each possible statistic type ISTAT of NSTATS.

  790     continue

ckpd    End if this error is requested for processing.

        endif

ckpd  End for each possible error type NER of the NKINDS of errors.

  800 continue

ckpd  Do we want to tag on a table of CARQ and WRNG position errors'
ckpd  means and standard deviations against the best track data?

      if (lposit) then

ckpd  If progress reporting is compiled in, mark a progress step.

cP    write(*,'(/,'' Status of position table run:'')')

        call posit(iodiag)

      endif

cF    if (iodiag)
cF   &  write(*,'('' Exiting triang()'')')

      write(*,'(''  '')')

cx    stop 'Triangle table program finished normally.'
      write (*, *) 'Triangle table program finished normally.'

      stop

      end
c-----------------------------------------------------------------------
      subroutine cerror(error,iodiag)
c-----------------------------------------------------------------------

      include 'triparms.inc'

      integer  error(naids,nerror,ntau)

      integer  ktau

      integer  jerr

      integer  iaid

      logical*1  iodiag

cF     if (iodiag)
cF    &  write(*,'('' Entering cerror()'')')

ckpd  Set the error array to "no data" value (-9999) for all entries.

      do 30 ktau=1,ntau

        do 20 jerr=1,nerror

          do 10 iaid=1,naids

            error(iaid,jerr,ktau) = -9999

   10     continue

   20   continue

   30 continue

cF     if (iodiag)
cF    &  write(*,'('' Exiting cerror()'')')

      return

      end
c-----------------------------------------------------------------------
      subroutine cmptr1(ntot,ntech,tri,iaid,jaid,ktau,iodiag
cP    &                  ,didprg
     &                 )
c-----------------------------------------------------------------------

ckpd  This subroutine does the arithmetic mean of absolute value of
ckpd  forecast errors part of the cmptri() calculations.  That routine
ckpd  became too complex for MS-FORTRAN 4.1 very early.

      include 'triparms.inc'

      integer       ntot(ntau)
      character*4   ntech(naids,ntau)
      real*8        tri(naids,naids,ntau,ntdata)

      integer       ktau
      integer       iaid
      integer       jaid
      integer       lpos


      logical*1     iodiag
cP     logical*1     didprg

ckpd  Curses!  MicroSoft-FORTRAN Compiler Release 4.1 cannot handle even
ckpd  moderately complex mathematical statements.  Declare some
ckpd  temporaries and do the calculations in chunks it can digest.

      real*8      rtemp
      real*8      stemp
      integer     itemp

cF     if (iodiag)
cF    &  write(*,'('' Entering cmptr1()'')')

ckpd  If there are any occurrences of this case
ckpd  (TRI(IAID,JAID,KTAU,koccur) > 0), then ...

      if (tri(iaid,jaid,ktau,koccur) .gt. dble(0.0)) then

ckpd    For each LPOS between the vertical and
ckpd    horizontal print axes ...

        do 200 lpos = iself,iother

ckpd  If progress reports are enabled, avoid writing over the previous
ckpd  line the first time an overstrike line is written.

cP     if (.not. didprg) then

cP       write(*,'(''  '')')
cP       didprg = .true.

cP     endif

ckpd  If progress reports are turned on at compile time, do one that
ckpd  repeatedly overwrites a single line so that the main routine
ckpd  progress report stays on screen.  By thus having a continuous
ckpd  I/O ongoing, a program interrupt (CTRL-C), which is only looked
ckpd  for at I/O time, will have quick effect.


cP     write(*,
cP    &  '(''+   fcst tau, #aids, col aid, row aid, diag#: '',
cP    &  i1,'', '',
cP    &  i2,'', '',
cP    &  i2,''='',a4,'', '',
cP    &  i2,''='',a4,'', '',
cP    &  i1,
cP    &  )')
cP    &  ktau,
cP    &  ntot(ktau),
cP    &  iaid,ntech(iaid,ktau),
cP    &  jaid,ntech(jaid,ktau),
cP    &  lpos

ckpd      Replace the "sum of absolute value of errors"
ckpd      contents of TRI(IAID,JAID,KTAU,LPOS) by the
ckpd      "mean absolute error" (contents divided by the
ckpd      occurrences).  Use floating point arthmetic so
ckpd      that we can round rather than truncate to get
ckpd      our result.

          tri(iaid,jaid,ktau,lpos) =
     &      tri(iaid,jaid,ktau,lpos) /
     &      tri(iaid,jaid,ktau,koccur)

ckpd    End for each LPOS between the vertical and
ckpd    horizontal print axes.

  200   continue

ckpd  Endif any occurrences.

      endif

cF     if (iodiag)
cF    &  write(*,'('' Exiting cmptr1()'')')

      return

      end
c-----------------------------------------------------------------------
      subroutine cmptr2(ntot,ntech,tri,tri1,iaid,jaid,ktau,iodiag
cP    &                  ,didprg
     &                 )
c-----------------------------------------------------------------------

ckpd  This subroutine does the Student's T and standard deviation of
ckpd  forecast errors part of the cmptri() calculations.  That routine
ckpd  became too complex for MS-FORTRAN 4.1 very early.

      include 'triparms.inc'

      integer       ntot(ntau)
      character*4   ntech(naids,ntau)
      real*8        tri(naids,naids,ntau,ntdata)
      real*8        tri1(naids,naids,ntau,n1data)

      integer       ktau
      integer       iaid
      integer       jaid
      integer       lpos


      real*8        slfmse
      real*8        othmse
      real*8        slfkoc
      real*8        othkoc
      real*8        slfdev
      real*8        othdev
      real*8        qval
      real*8        sqrtmp
      integer       ier

      logical*1     iodiag
cP     logical*1     didprg


ckpd  Curses!  MicroSoft-FORTRAN Compiler Release 4.1 cannot handle even
ckpd  moderately complex mathematical statements.  Declare some
ckpd  temporaries and do the calculations in chunks it can digest.

      integer       itemp
      real*8        rtemp
      real*8        stemp
      real*8        ttemp
      real*8        utemp
      real*8        vtemp
      real*8        wtemp
      real*8        xtemp

cF     if (iodiag)
cF    &  write(*,'('' Entering cmptr2()'')')

ckpd  If there are any occurrences of this case
ckpd  (TRI(IAID,JAID,KTAU,koccur) > 0), then ...

      if (tri(iaid,jaid,ktau,koccur) .gt. dble(0.0)) then

ckpd    For each LPOS between the vertical and
ckpd    horizontal print axes ...

        do 210 lpos = iself,iother

ckpd  If progress reports are enabled, avoid writing over the previous
ckpd  line the first time an overstrike line is written.

cP     if (.not. didprg) then

cP       write(*,'(''  '')')
cP       didprg = .true.

cP     endif

ckpd  If progress reports are turned on at compile time, do one that
ckpd  repeatedly overwrites a single line so that the main routine
ckpd  progress report stays on screen.  By thus having a continuous
ckpd  I/O ongoing, a program interrupt (CTRL-C), which is only looked
ckpd  for at I/O time, will have quick effect.

cP     write(*,
cP    &  '(''+   fcst tau, #aids, col aid, row aid, diag#: '',
cP    &  i1,'', '',
cP    &  i2,'', '',
cP    &  i2,''='',a4,'', '',
cP    &  i2,''='',a4,'', '',
cP    &  i1,
cP    &  )')
cP    &  ktau,
cP    &  ntot(ktau),
cP    &  iaid,ntech(iaid,ktau),
cP    &  jaid,ntech(jaid,ktau),
cP    &  lpos

ckpd      Replace the "sum of signed errors" contents of
ckpd      TRI(IAID,JAID,KTAU,LPOS) by the "mean of signed errors",
ckpd      (contents divided by the occurrences).
ckpd      our result.

          tri(iaid,jaid,ktau,lpos) =
     &      tri(iaid,jaid,ktau,lpos) / tri(iaid,jaid,ktau,koccur)


ckpd    End for each LPOS between the vertial and
ckpd    horizontal print axes ...

  210   continue

ckpd    Since we're about to clobber them but need them real soon again,
ckpd    and in floating point form, save the "mean of signed errors" in
ckpd    TRI(IAID,JAID,KTAU,iself and iother) into temporaries slfmse and
ckpd    othmse, and the count of the occurrences of these forecasts in
ckpd    common stored in TRI(IAID,JAID,KTAU,koccur) into temporaries
ckpd    slfkoc and also othkoc.

        slfmse = tri(iaid,jaid,ktau,iself)

        othmse = tri(iaid,jaid,ktau,iother)

        slfkoc = tri(iaid,jaid,ktau,koccur)

        othkoc = tri(iaid,jaid,ktau,koccur)

ckpd    Replace TRI(IAID,JAID,KTAU,iself) with the standard deviation of
ckpd    the "self against self" errors, gotten as the square root of
ckpd    the: [mean of the squared signed errors {sum of the squared
ckpd    errors (from TRI1(IAID,JAID,KTAU,iself)) divided by the count of
ckpd    occurrences (from TRI(IAID,JAID,KTAU,koccur))}, less the square
ckpd    of the "mean signed errors" (from TRI(IAID,JAID,KTAU,iself)].

        sqrtmp =
     &    ( tri1(iaid,jaid,ktau,iself) / tri(iaid,jaid,ktau,koccur) ) -
     &    ( tri(iaid,jaid,ktau,iself)  * tri(iaid,jaid,ktau,iself)  )

        if (sqrtmp .ge. dble(0.0)) then

          tri(iaid,jaid,ktau,iself) = dsqrt(sqrtmp)

        else

cW         write(ludiag,
cW    &      '('' cmptr2(): "sqrt('',g18.12,'')" caught'',
cW    &        '' in self versus self T-test setup;'',
cW    &      /,''   tri1('',i3,'','',i3,'','',i1,'',iself) = '',g18.12,
cW    &      /,''   tri('',i3,'','',i3,'','',i1,'',koccur) = '',g18.12,
cW    &      /,''   tri('',i3,'','',i3,'','',i1,'',iself)  = '',g18.12,
cW    &      /,'' Setting the result to zero in hopes it is'',
cW    &        '' roundoff noise.'')')
cW    &      sqrtmp,
cW    &      iaid,jaid,ktau,tri1(iaid,jaid,ktau,iself),
cW    &      iaid,jaid,ktau,tri(iaid,jaid,ktau,koccur),
cW    &      iaid,jaid,ktau,tri(iaid,jaid,ktau,iself)

          tri(iaid,jaid,ktau,iself) = dble(0.0)

        endif

ckpd    Copy the resulting "self" value to another temporary, slfdev.

        slfdev = tri(iaid,jaid,ktau,iself)

ckpd    Replace TRI(IAID,JAID,KTAU,iother) with the standard deviation
ckpd    of the "self against other" errors, analogously.

        sqrtmp =
     &    ( tri1(iaid,jaid,ktau,iother) / tri(iaid,jaid,ktau,koccur) ) -
     &    ( tri(iaid,jaid,ktau,iother)  * tri(iaid,jaid,ktau,iother) )

        if (sqrtmp .ge. dble(0.0)) then

          tri(iaid,jaid,ktau,iother) = dsqrt(sqrtmp)

        else

cW         write(ludiag,
cW    &      '('' cmptr2(): "sqrt('',g18.12,'')" caught'',
cW    &        '' in self versus other T-test setup;'',
cW    &      /,''   tri1('',i3,'','',i3,'','',i1,'',iother) = '',g18.12,
cW    &      /,''   tri('',i3,'','',i3,'','',i1,'',koccur) = '',g18.12,
cW    &      /,''   tri('',i3,'','',i3,'','',i1,'',iother) = '',g18.12,
cW    &      /,'' Setting the result to zero in hopes it is'',
cW    &        '' roundoff noise.'')')
cW    &      sqrtmp,
cW    &      iaid,jaid,ktau,tri1(iaid,jaid,ktau,iother),
cW    &      iaid,jaid,ktau,tri(iaid,jaid,ktau,koccur),
cW    &      iaid,jaid,ktau,tri(iaid,jaid,ktau,iother)
 
          tri(iaid,jaid,ktau,iother) = dble(0.0)

        endif

ckpd    Copy the resulting "other" value to another temporary, othdev

        othdev = tri(iaid,jaid,ktau,iother)

ckpd    If there are at least 60 counts between slfkoc and othkoc, then
ckpd    we can compute a Student's T value:

        if ((slfkoc + othkoc) .ge. 60.0) then

ckpd      Call the ttest subroutine passing it the temporaries
ckpd      appropriately, and getting back a result in temporary QVAL and
ckpd      an IMSL error flag in temporary IER.

          call ttest
     &      (slfmse,othmse,slfkoc,othkoc,slfdev,othdev,qval,ier,iodiag)

ckpd      If IER is OK, then ...

          if (ier .eq. 0) then

ckpd        Store 100 times (1.0 - Q) (the integer percent version of
ckpd        the Student's T value) into the usual occurrences location
ckpd        (TRI(IAID,JAID,KTAU,koccur)).

            tri(iaid,jaid,ktau,koccur) =
     &        (dble(1.0) - qval) * dble(100.0)


ckpd      Else IER showed a problem, so ...

          else

ckpd        Store the "no value" (nodata) flag in
ckpd        TRI(IAID,JAID,KTAU,koccur).

            tri(iaid,jaid,ktau,koccur) = dble(nodata)

ckpd      Endif IER is OK

          endif

ckpd    Else we can't compute a useful statistic, so ...

        else

ckpd      Store the "no value" (nodata) flag in
ckpd      TRI(IAID,JAID,KTAU,koccur).

          tri(iaid,jaid,ktau,koccur) = dble(nodata)

ckpd    Endif enough occurrences for Student's T.

        endif

ckpd  Endif any occurrences.

      endif

cF     if (iodiag)
cF    &  write(*,'('' Exiting cmptr2()'')')

      return

      end
c-----------------------------------------------------------------------
      subroutine cmptr3(ntot,ntech,tri,tri1,iaid,jaid,ktau,iodiag
cP    &                  ,didprg
     &                 )
c-----------------------------------------------------------------------

      include 'triparms.inc'

      integer       ntot(ntau)
      character*4   ntech(naids,ntau)
      real*8        tri(naids,naids,ntau,ntdata)

      real*8        tri1(naids,naids,ntau,n1data)

      integer       iaid
      integer       jaid
      integer       ktau
      integer       itemp
      integer       jtemp
      integer       ktemp

      logical*1     iodiag
cP     logical*1     didprg

      real*8        rtemp
      real*8        stemp
      real*8        ttemp

      integer       gmamed
      external      gmamed


ckpd  Subroutine CMPTR3 computes the Gamma Median, the third error
ckpd  statistic possibility this program can generate.  The Gamma Median
ckpd  is an estimate of the median value of a set of samples that is
ckpd  less memory storage space intensive than an arithmetic median,
ckpd  which requires at least a counting bin for each input possible
ckpd  value.  The Gamma Median is a valid estimator under the assumption
ckpd  that the data distribution approximates one of the family of Gamma
ckpd  function curves (a fairly easy assumption to meet, because the
ckpd  Gamma function family includes everything from a Poisson
ckpd  distribution to an approximate single tailed "normal" curve for
ckpd  positive definite data.

cF     if (iodiag)
cF    &  write(*,'('' Entering cmptr3().'')')

ckpd  For each LPOS between the vertical and horizontal print axes ...

      do 100 lpos = iself,iother

ckpd  If progress reports are enabled, avoid writing over the previous
ckpd  line the first time an overstrike line is written.

cP     if (.not. didprg) then

cP       write(*,'(''  '')')
cP       didprg = .true.

cP     endif

ckpd  If progress reports are turned on at compile time, do one that
ckpd  repeatedly overwrites a single line so that the main routine
ckpd  progress report stays on screen.  By thus having a continuous
ckpd  I/O ongoing, a program interrupt (CTRL-C), which is only looked
ckpd  for at I/O time, will have quick effect.

cP     write(*,
cP    &  '(''+   fcst tau, #aids, col aid, row aid, diag#: '',
cP    &  i1,'', '',
cP    &  i2,'', '',
cP    &  i2,''='',a4,'', '',
cP    &  i2,''='',a4,'', '',
cP    &  i1,
cP    &  )')
cP    &  ktau,
cP    &  ntot(ktau),
cP    &  iaid,ntech(iaid,ktau),
cP    &  jaid,ntech(jaid,ktau),
cP    &  lpos

ckpd    If there are at least ten occurrences, to make enough for a
ckpd    meaningful statistic, then ...

        if (tri(iaid,jaid,ktau,koccur) .ge. dble(10.0)) then

ckpd      Set TRI(IAID,JAID,KTAU,LPOS) to the value returned by the
ckpd      gamma median routine when given the sum of errors, in this TRI
ckpd      location, the sum of natural logs of errors with a constant
ckpd      GAMOFF offset, in the corresponding TRI1 location, and the
ckpd      count of occurrences, from TRI(IAID,JAID,KTAU,koccur).


ckpd  ----------------- Here's the Gamma Median Call -------------------

          tri(iaid,jaid,ktau,lpos) =
     &      gmamed(tri(iaid,jaid,ktau,lpos),
     &             tri1(iaid,jaid,ktau,lpos),
     &             tri(iaid,jaid,ktau,koccur),
     &             iodiag)

ckpd  ------------------------------------------------------------------


ckpd    Else there are insufficient occurrences, so ...

        else

ckpd      Set TRI(IAID,JAID,KTAU,LPOS) to the "no data" value nodata
ckpd      (see the parameter file for its explicit value).

          tri(iaid,jaid,ktau,lpos) = dble(nodata)

ckpd    Endif at least ten occurrences.

        endif

ckpd  End for each LPOS between the vertical and horizontal print axes.

  100 continue

ckpd  Return to the calling routine.

cF     if (iodiag)
cF    &  write(*,'('' Exiting cmptr3().'')')

      return

      end
c-----------------------------------------------------------------------      
      subroutine cmptri(ntot,ntech,tri,tri1,istat,iodiag)
c-----------------------------------------------------------------------

      include 'triparms.inc'

      integer       ntot(ntau)
      character*4   ntech(naids,ntau)
      real*8        tri(naids,naids,ntau,ntdata)
      real*8        tri1(naids,naids,ntau,n1data)
      integer       istat

      integer       ktau
      integer       iaid
      integer       jaid


      logical*1     iodiag
cP     logical*1     didprg

cF     if (iodiag)
cF    &  write(*,'('' Entering cmptri()'')')

cP     didprg = .false.

ckpd  The triangle tables are loaded and uninteresting data
ckpd  compressed out.  Now use their contents to finish the
ckpd  computations for the currently requested statistic.

ckpd  For each KTAU in the NTAU possible forecast taus ...

      do 780 ktau = 1,ntau

ckpd    For each JAID among the NTOT(KTAU) remaining techniques
ckpd    having interesting values for this KTAU ...

        do 770 jaid = 1,ntot(ktau)

ckpd      For each IAID up to and including JAID (to make a
ckpd      triangle!) ...

          do 760 iaid = 1,jaid

ckpd        case ISTAT of

ckpd        Dummy up a case statement by using "else if"s as
ckpd        "elsif"s:

ckpd        Arithmetic Mean:

            if (istat .eq. meanab) then

              call cmptr1(ntot,ntech,tri,iaid,jaid,ktau,iodiag
cP    &                    ,didprg
     &                   )

ckpd        End Arithmetic Mean case.

ckpd        Student's T:

            else if (istat .eq. studev) then

              call cmptr2(ntot,ntech,tri,tri1,iaid,jaid,ktau,iodiag
cP    &                    ,didprg
     &                   )

ckpd        End Student's T case.

ckpd        Gamma Median:

            else if (istat .eq. medgam) then

              call cmptr3(ntot,ntech,tri,tri1,iaid,jaid,ktau,iodiag
cP    &                    ,didprg
     &                   )

ckpd        End Gamma Median case.

ckpd        Arithmetic Median of Signed Errors:

            else if (istat .eq. medsgn) then

            continue

ckpd        End Arithmetic Median of Signed Errors case.

ckpd        Arithmetic Median of Absolute Errors:

            else if (istat .eq. medabs) then

            continue

ckpd        End Arithmetic Median of Absolute Errors case.

ckpd        End case ISTAT.

            endif

ckpd      End for each IAID up to and including JAID (to make a
ckpd      triangle!).

  760     continue

ckpd    End for each JAID among the NTOT(KTAU) remaining
ckpd    techniques having interesting values for this KTAU.

  770   continue

ckpd  End for each KTAU in the NTAU possible forecast taus.

  780 continue

cF     if (iodiag)
cF    &  write(*,'('' Exiting cmptri()'')')

      return

      end
c-----------------------------------------------------------------------
      subroutine ctri(tri,iodiag)
c-----------------------------------------------------------------------

      include 'triparms.inc'

      real*8           tri(naids,naids,ntau,ntdata)
      logical*1        iodiag
      integer          iaid
      integer          jaid
      integer          ktau
      integer          lpos

cF     if (iodiag)
cF    &  write(*,'('' Entering ctri()'')')

      do 40 lpos = 1,ntdata
        do 30 ktau = 1,ntau
          do 20 jaid = 1,naids
            do 10 iaid = 1,naids

              tri(iaid,jaid,ktau,lpos)=dble(0.0)

   10       continue
   20     continue
   30   continue
   40 continue

cF     if (iodiag)
cF    &  write(*,'('' Exiting ctri()'')')

      return

      end
c-----------------------------------------------------------------------
      subroutine ctri1(tri1,iodiag)
c-----------------------------------------------------------------------

      include 'triparms.inc'

      real*8         tri1(naids,naids,ntau,n1data)
      logical*1      iodiag
      integer        iaid
      integer        jaid
      integer        ktau
      integer        lpos

cF     if (iodiag)
cF    &  write(*,'('' Entering ctri1()'')')

      do 40 lpos = 1,n1data
        do 30 ktau = 1,ntau
          do 20 jaid = 1,naids
            do 10 iaid = 1,naids

              tri1(iaid,jaid,ktau,lpos)=0.0

   10       continue
   20     continue
   30   continue
   40 continue

cF     if (iodiag)
cF    &  write(*,'('' Exiting ctri1()'')')

      return

      end
      subroutine dzilch( d , n )

c     RJM  This subroutine is designed after an FNWC subroutine by the
c          same name.  All this routine does is zero out the passed
c     array.

c     KPD  Declare subprogram input parameters.

      integer     n

      real*8      d( n )

c     KPD  Declare variables peculiar to this routine.

      integer     i

cF     call prctrc( 'dzilch' , .true. )


      do 100 i=1,n

         d(i) = 0.0

  100 continue

cF     call prctrc( 'dzilch' , .false. )

      return

      end
      subroutine eatlin(iunit,numlin,iodiag)

ckpd  This routine reads and discards numlin lines from the file whose
ckpd  logical unit number is iunit.  It is a separate routine only
ckpd  because it is called several places.  The lines being skipped are
ckpd  typically comment lines in files that are otherwise data tables.

      integer     iunit
      integer     numlin
      integer     kline
      character*1 ctemp
      logical*1   iodiag

cF     if (iodiag)
cF    &  write(*,'('' Entering eatlin()'')')

      do 100 kline = 1,numlin

        read(iunit,'(a1)') ctemp

  100 continue

cF     if (iodiag)
cF    &  write(*,'('' Exiting eatlin()'')')

      return

      end
c-----------------------------------------------------------------------
      subroutine ferror(ntech,stdtau,astats,error,storm,fstdy,lstdy,
     &                  indone,istat,ntused,ner,iodiag)
c-----------------------------------------------------------------------

      include 'triparms.inc'

ckpd  idif     -- The difference in units of six hour synoptic periods
ckpd              between the beginning of a storm, and the time of the
ckpd              currently considered forecast; used to build the
ckpd              second index for array "error" as it is being filled
ckpd              with data.

      integer          idif

ckpd  ndif     -- The difference in units of six hour synoptic periods
ckpd              between the beginning of a storm (first data synoptic
ckpd              period) and the end of the storm (last data synoptic
ckpd              period).

      integer          ndif

ckpd  nowtau   -- Holds the "tau" or forecast future offset from the
ckpd              forecast's synoptic time, for the current data card
ckpd              during some sanity checks.

      integer          nowtau

      integer          stdtau(ntau)
      integer          error(naids,nerror,ntau)
      integer          errin(nkinds)
      integer          iaid
      integer          itau
      integer          ntused
      integer          ner
      integer          istat
      integer          kerr
      integer          ktau
      logical*1        indone
      logical*1        stdone
      logical*1        iodiag

      character*4      ntech(naids,ntau)
      character*38     astats(nstats)
      character*80     line
      character*4      itech
      character*6      storm
      character*8      dtg
      character*8      fstdy
      character*8      lstdy

cF     if (iodiag)
cF    &  write(*,'('' Entering ferror()'')')

ckpd  ---------------------- loop on data cards ------------------------

ckpd  For each data card in this single storm's input data.

      stdone = .false.

   10 continue

ckpd    Read the data card into character array LINE.

        read(luinpt,'(a80)',end=40) line
cx      for some reason, I need this print to make triangle work on HP!!!
cx      this is probably because we are crushing something in memory!!!
cx      sampson, nrl 
cx      print *, line

ckpd    Bypass data cards blank in the first six columns.

        if (line(1:6) .eq. '      ') then

cD         if (iodiag)
cD    &      write(*,'('' Bypassing because blank in columns 1-6:'',
cD    &      /,1x,a80)') line

        else

ckpd      if the STORM has changed

          if (line(pstmid:pstmid+lstmid-1) .ne. storm) then

cD           if (iodiag)
cD    &        write(*,'('' Bypassing because storm name changed:'',
cD    &        /,1x,a80)') line

ckpd        Capture the new storm name, we're done with the
ckpd        old one.

            storm = line(pstmid:pstmid+lstmid-1)

ckpd        Back up a card to see this one again when we start the next
ckpd        storm loop.

            backspace luinpt

ckpd        Flag the change so we can drop out of this loop. (The
ckpd        alternative is to nest the rest of the storm processing
ckpd        below this level, possible but difficult to depict nicely
ckpd        due to Fortran's line limits.)

            stdone = .true.

ckpd      else the storm hasn't changed, so go on ...

          else

ckpd        Interpret the ascii technique name ITECH, the forecast time
ckpd        offset ITAU, the card date time group DTG, and the eight
ckpd        error types ERRIN(1) to ERRIN(8) from the input data card.

            read (line,'(2x,a4,i3,a8,8i5)')
     &        itech,itau,dtg,(errin(kerr),kerr=1,nkinds)

ckpd        if FSTDY is still zero, copy DTG to FSTDY

            if (fstdy .eq. '00000000') fstdy = dtg

ckpd        if the card is out of order (DTG < FSTDY) then

cajs        if (dtg .lt. fstdy) then
            call dtgdif( fstdy, dtg, idif )
            if( idif .lt. 0 ) then

ckpd          Ignore the card and warn the user.

ckpd           write(*,'('' This out of order data card'',
ckpd &              '' being ignored:'')')
 
ckpd           write(*,'(1x,a80)') line

cW             write(*,'('' Continuing processing, but do'',
cW    &          '' not trust output until data is fixed.'')')

ckpd        else the card is in the proper order so go ahead

            else

ckpd          If the error has a "no data" value, quit early.

              if (errin(ner) .eq. nodata) then

ckpd            Do nothing.


cD               if (iodiag)
cD    &            write(*,'('' Bypassing because errin('',i1,
cD    &            '') has "no data" entry:'',
cD    &            /,1x,a80)') line

                continue

              else

ckpd  -------------------- loop on requested aids ----------------------

ckpd            For each forecast aid type IAID in NTECH(IAID,1) ...

                do 30 iaid = 1,ntused

ckpd              If the technique ITECH is not one of the requested ones
ckpd              in NTECH, then

                  if (itech .ne. ntech(iaid,1)) then

ckpd                Do nothing, ignore the card.

                    continue

ckpd              Else we have an aid on this data card whose processing
ckpd              has been requested by the user through flags in the
ckpd              technique list input file.

                  else

ckpd                If this ERRIN(NER) value is outside of limits for
ckpd                this kind of statistic (ERR(NER) < -GAMOFF (see the
ckpd                parameter file for its value) for statistic Gamma
ckpd                Median), then

                    if ((istat .eq. medgam) .and.
     &                  (errin(ner) .le. -gamoff)) then

ckpd                  Ignore the card and report the omission; this
ckpd                  protects against taking a natural log of a number
ckpd                  <= zero in later code.

cW                     write(*,'('' Error '',i6,
cW    &                  '' too negative for statistic '',a38,
cW    &                  /,1x,a80)') errin(ner),astats(istat),line

ckpd                Else the value is in limits, for the current
ckpd                statistic, so continue.

                    else

ckpd                  From DTG and FSTDY, compute IDIF, the number of
ckpd                  six hour synoptic periods DTG is after the storm's
ckpd                  "birth", FSTDY, in the input data file, plus one
ckpd                  for a Fortran "1" origin array index.

                      call dtgdif (fstdy,dtg,idif)

                      idif = idif/6 + 1

ckpd                  From ITAU compute NOWTAU, the ordinal offset of
ckpd                  the forecast this card represents from the
ckpd                  synoptic time of the forecast, in units of one
ckpd                  forecast interval or a variable number of hours
ckpd                  either 12 or 24, again adjusted for an index to a
ckpd                  "1" origin Fortran array.

ckpd FIXME            MAINTENANCE WARNING:  This won't work and is
ckpd FIXME            inappropriate if the ATCF storm and aids data
ckpd FIXME            storage are ever revised to capture the actual tau
ckpd FIXME            offset of a non-standard last forecast position.
ckpd FIXME            Right now they incorrectly store a tau 66 forecast
ckpd FIXME            as a tau 72 forecast, so this program follows that
ckpd FIXME            error in blind ignorance.  See the knownbug.doc
ckpd FIXME            file for more discussion about this.

ckpd FIXME CONTEXT       data stdtau /12,24,36,48,72/
ckpd FIXME CONTEXT       if (stdtau(ktau).eq.iabs(itau)) nowtau = ktau

ckpd                  Set NOWTAU to a value that will flag a failure to
ckpd                  match a legal forecast time.

                      nowtau = -1

                      do 20 ktau = 1,ntau

                        if ( stdtau(ktau) .eq. iabs(itau) )
     &                    nowtau = ktau

   20                 continue

ckpd                  Protect against itau errors:

                      if ( (nowtau .lt. 1) .or.
     &                  (nowtau .gt. ntau) ) then

                        continue

cW                       write(*,'('' Invalid forecast hour'',
cW    &                            '' in this ddeck line:'')')

cW                       write(*,'(1x,a80)') line

cW                       write(*,'('' Continuing processing,'',
cW    &                    '' but do not trust output until'',
cW    &                    '' data is fixed.'')')

ckpd                  else nowtau looks OK, so continue

                      else

ckpd  ------------------------ store the error -------------------------

ckpd                    Everything else in this deeply nested set of
ckpd                    statements within the storm data card loop is
ckpd                    protection from errors. Here is the statement
ckpd                    doing the work.

ckpd                    Store the current error (ERRIN(NER)) value for
ckpd                    this storm, error type, and data card into array
ckpd                    ERROR at location ERROR(IAID,IDIF,NOWTAU).

                        error(iaid,idif,nowtau) = errin(ner)

cD                       if (iodiag)
cD    &                    write(*,'('' stored errin('',i1,'') = '',i5,
cD    &                    '' at error('',i3,'','',i4,'','',i2,'')'')')
cD    &                    ner,errin(ner),iaid,idif,nowtau

cD                       if (iodiag)
cD    &                    write(*,'('' From line:'',/,1x,a80)') line


ckpd                    Store DTG into LSTDY to indicate that some data
ckpd                    was saved from this storm and to enable a storm
ckpd                    length computation to be done later.

                        if (dtg .gt. lstdy) lstdy = dtg

ckpd                  Endif nowtau has an illegal value.

                      endif

ckpd                Endif this error is out of limits for this
ckpd                statistic.

                    endif

ckpd              Endif this technique is not requested.

                  endif

ckpd            End for each error type IAID in NTECH(IAID,1).

   30           continue

ckpd          Endif the error being sought is a "no data" value

              endif

ckpd        Endif the card is out of order.

            endif

ckpd      Endif storm has changed.

          endif

ckpd    Endif else the card is not blank in the first six
ckpd    characters.

        endif

ckpd    Yuk!  The only obvious way to do this with the weak
ckpd    "end=" of a Fortran read statement is a rash of GOTOs,
ckpd    since we need to do the end of storm processing and so
ckpd    cannot just jump down to the end of input processing
ckpd    yet.  Oh, the embarrassment! Sob!

        goto 50

ckpd    End on the read of the input data drops us here.

   40   continue

ckpd    Set a flag for input data set exhausted, so we don't
ckpd    come back and keep trying to read from it.

        indone = .true.

ckpd    Set another flag for this storm being done, which will
ckpd    drop us to go through the end of this ersatz "do ...
ckpd    until" statement to accomplish the end of storm
ckpd    processing for this last storm before we do the end of
ckpd    input data processing.

        stdone = .true.

   50   continue

ckpd  End for each data card in this single storm's input data.

      if (.not. stdone) goto 10

ckpd  At the end of a storm, and possibly the end of the input data
ckpd  file, with array ERROR possibly full of useful values, return.

cF     if (iodiag)
cF    &  write(*,'('' Exiting ferror()'')')

      return

      end
c-----------------------------------------------------------------------
      subroutine filtri(error,tri,tri1,fstdy,lstdy,istat,ntused,iodiag)
c-----------------------------------------------------------------------

ckpd  Fill the double precision real triangle table TRI and the double
ckpd  precision real triangle table TRI1, accumulating into both of them
ckpd  values from integer array ERROR.  The tables are "triangle tables"
ckpd  because only entries on or below the hypotenuse of the square data
ckpd  array of side length "number of aids being compared" is of
ckpd  interest. Although the same program code handles on-hypotenuse and
ckpd  below-hypotenuse entries, the logic of the results is different.
ckpd  Below-hypotenuse entries are comparisions of the aids against
ckpd  other aids, so values are accumulated for "own errors" in the
ckpd  first array location of the last subscript, and for "matching
ckpd  aid's errors" in the second array location of the last subscript
ckpd  for the triangle.  [The third array location is always used to
ckpd  count the number of cases whose errors are being accumulated in
ckpd  the other two locations.]

ckpd  On-hypotenuse entries are "comparisions" of the forecast aid
ckpd  against itself, so the first and second locations receive the same
ckpd  data, primarily just because this makes printing the triangle
ckpd  tables less filled with special cases.

      include 'triparms.inc'

      integer          error(naids,nerror,ntau)
      real*8           tri(naids,naids,ntau,ntdata)
      real*8           tri1(naids,naids,ntau,n1data)
      real*8           rtemp
      integer          ndif
      integer          istat
      integer          ntused
      integer          iaid
      integer          jsyn
      integer          ktau
      integer          laid
      character*8      fstdy
      character*8      lstdy
      logical*1        iodiag

cF     if (iodiag)
cF    &  write(*,'('' Entering filtri()'')')

ckpd  --------------------- fill triangle tables -----------------------

ckpd            If LSTDY indicates some data was captured to ERROR(),
ckpd            then ...

                if (lstdy .ne. '00000000') then

ckpd              From FSTDY and LSTDY compute NDIF, the length of the
ckpd              storm in synoptic (six hour) periods, adjusted to be a
ckpd              "1" origin Fortran array index.

                  call dtgdif(fstdy,lstdy,ndif)

ckpd              for each IAID of the NT requested techniques

                  do 600 iaid = 1,ntused

ckpd                For each JSYN in the NDIF synoptic periods of the
ckpd                storm's life.

                    do 590 jsyn = 1,ndif

ckpd                  For each KTAU in the 5 possible forecast offset
ckpd                  taus ...

                      do 580 ktau = 1,ntau

ckpd                    for each LAID of the NTUSED requested techniques

                        do 570 laid = 1,ntused

ckpd                      For this three way case statement, rather than
ckpd                      use the deprecated Fortran three way branch
ckpd                      statement, use "else if" as an imitation case
ckpd                      statement, to avoid ever deeper indentation.

ckpd                      if LAID < IAID then

                          if (laid .lt. iaid) then

ckpd                        Do nothing!

                            continue

ckpd FIXME                  (These unused parts of the triangle arrays
ckpd FIXME                  use up storage that can be recaptured by
ckpd FIXME                  being smarter about explicitly computing
ckpd FIXME                  the triangular [1 to (n+1)*n/2] index
ckpd FIXME                  while using one fewer explicit indexing
ckpd FIXME                  levels, thereby almost doubling the
ckpd FIXME                  duration of a storm that can be processed
ckpd FIXME                  by this routine; there are occasional very
ckpd FIXME                  long lived tropical cyclones)

ckpd                      End if LAID < IAID do nothing case.  No
ckpd                      closing endif needed, Fortran does an
ckpd                      "elsif" construct very happily.

ckpd                      Elsif LAID >= IAID do the interesting
ckpd                      cases; find any other aid error in ERROR()
ckpd                      that has a valid value at this same
ckpd                      ("matching") JSYN and KTAU, and fold its
ckpd                      value into the (IAID,LAID,KTAU,iother) slots of
ckpd                      TRI and TRI1, while folding the "current"
ckpd                      value into the (IAID,LAID,KTAU,iself) slots.

                          else

                            if ((error(iaid,jsyn,ktau) .eq. nodata)
     &                        .or. (error(laid,jsyn,ktau) .eq. nodata))
     &                        then

                              continue

ckpd                        Else there is some [or a pair of, depending
ckpd                        on whether this is an on- or off-hypotenuse
ckpd                        triangle element] good data value[s], so ...

                            else


ckpd                          Case ISTAT of ...

ckpd                          Dummy up a case statement by using "else
ckpd                          if"s as "elsif"s:

ckpd                          Arithmetic Mean:

                              if (istat .eq. meanab) then

ckpd                            Add the absolute value of the "current"
ckpd                            ERROR(IAID,JSYN,KTAU) to
ckpd                            TRI(IAID,LAID,KTAU,iself).

                                tri(iaid,laid,ktau,iself) =
     &                            tri(iaid,laid,ktau,iself) +
     &                            dabs(dble(error(iaid,jsyn,ktau)))

ckpd                            Add the absolute value of the "matching"
ckpd                            ERROR(LAID,JSYN,KTAU) to
ckpd                            TRI(IAID,LAID,KTAU,iother).

                                tri(iaid,laid,ktau,iother) =
     &                            tri(iaid,laid,ktau,iother) +
     &                            dabs(dble(error(laid,jsyn,ktau)))

ckpd                            End Arithmetic Mean case.

ckpd                          Student's T:

                              else if (istat .eq. studev) then

cD     rtemp = tri(iaid,laid,ktau,iself)

ckpd                            Add the signed value of the "current"
ckpd                            ERROR(IAID,JSYN,KTAU) to
ckpd                            TRI(IAID,LAID,KTAU,iself).

                                tri(iaid,laid,ktau,iself) =
     &                            tri(iaid,laid,ktau,iself) +
     &                            dble(error(iaid,jsyn,ktau))

cD     write(ludiag,
cD    &  '('' filtri():'',
cD    &  /,''  ['',g18.12,''] = tri('',i2,'','',i2,'','',i1,'','',i1,
cD    &  '') = '',
cD    &  /,''  tri('',i2,'','',i2,'','',i1,'','',i1,'') ['',g18.12,
cD    &    ''] +'',
cD    &  /,''  error('',i2,'','',i3,'','',i1,'') ['',i5,'']'',
cD    &  /)') tri(iaid,laid,ktau,iself),iaid,laid,ktau,iself,
cD    &  iaid,laid,ktau,iself,rtemp,
cD    &  iaid,jsyn,ktau,error(iaid,jsyn,ktau)

cD     rtemp = tri(iaid,laid,ktau,iother)

ckpd                            Add the signed value of the "matching"
ckpd                            ERROR(LAID,JSYN,KTAU) to
ckpd                            TRI(IAID,LAID,KTAU,iother).

                                tri(iaid,laid,ktau,iother) =
     &                            tri(iaid,laid,ktau,iother) +
     &                            error(laid,jsyn,ktau)

cD     write(ludiag,
cD    &  '('' filtri():'',
cD    &  /,''  ['',g18.12,''] = tri('',i2,'','',i2,'','',i1,'','',i1,
cD    &  '') = '',
cD    &  /,''  tri('',i2,'','',i2,'','',i1,'','',i1,'') ['',g18.12,
cD    &    ''] +'',
cD    &  /,''  error('',i2,'','',i3,'','',i1,'') ['',i5,'']'',
cD    &  /)') tri(iaid,laid,ktau,iother),iaid,laid,ktau,iother,
cD    &  iaid,laid,ktau,iother,rtemp,
cD    &  laid,jsyn,ktau,error(laid,jsyn,ktau)

ckpd                            Add the square of the "current"
ckpd                            ERROR(IAID,JSYN,KTAU) value into
ckpd                            TRI1(IAID,LAID,KTAU,iself).

cD     rtemp = tri1(iaid,laid,ktau,iself)

                                tri1(iaid,laid,ktau,iself) =
     &                            tri1(iaid,laid,ktau,iself) +
     &                            (dble(error(iaid,jsyn,ktau)) *
     &                            dble(error(iaid,jsyn,ktau)))

cD     write(ludiag,
cD    &  '('' filtri():'',
cD    &  /,''  ['',g18.12,''] = tri1('',i2,'','',i2,'','',i1,'','',i1,
cD    &  '') = '',
cD    &  /,''  tri1('',i2,'','',i2,'','',i1,'','',i1,'') ['',g18.12,
cD    &    ''] +'',
cD    &  /,''  (error('',i2,'','',i3,'','',i1,'') ['',i5,''] *'',
cD    &  /,''  error('',i2,'','',i3,'','',i1,'') ['',i5,''])'',
cD    &  /)') tri1(iaid,laid,ktau,iself),iaid,laid,ktau,iself,
cD    &  iaid,laid,ktau,iself,rtemp,
cD    &  iaid,jsyn,ktau,error(iaid,jsyn,ktau),
cD    &  iaid,jsyn,ktau,error(iaid,jsyn,ktau)
 
ckpd                            Add the square of the "matching"
ckpd                            ERROR(LAID,JSYN,KTAU) value into
ckpd                            TRI1(IAID,LAID,KTAU,iother).

cD     rtemp = tri1(iaid,laid,ktau,iother)

                                tri1(iaid,laid,ktau,iother) =
     &                            tri1(iaid,laid,ktau,iother) +
     &                            (dble(error(laid,jsyn,ktau)) *
     &                            dble(error(laid,jsyn,ktau)))

cD     write(ludiag,
cD    &  '('' filtri():'',
cD    &  /,''  ['',g18.12,''] = tri1('',i2,'','',i2,'','',i1,'','',i1,
cD    &  '') = '',
cD    &  /,''  tri1('',i2,'','',i2,'','',i1,'','',i1,'') ['',g18.12,
cD    &    ''] +'',
cD    &  /,''  (error('',i2,'','',i3,'','',i1,'') ['',i5,''] *'',
cD    &  /,''  error('',i2,'','',i3,'','',i1,'') ['',i5,''])'',
cD    &  /)') tri1(iaid,laid,ktau,iother),iaid,laid,ktau,iother,
cD    &  iaid,laid,ktau,iother,rtemp,
cD    &  iaid,jsyn,ktau,error(laid,jsyn,ktau),
cD    &  iaid,jsyn,ktau,error(laid,jsyn,ktau)

ckpd                          End Student's T case.

ckpd                          Gamma Median:

                              else if (istat .eq. medgam) then

ckpd                            Add the signed value of the "current"
ckpd                            ERROR(IAID,JSYN,KTAU) to
ckpd                            TRI(IAID,LAID,JSYN,KTAU,iself).

cD     if (iodiag) write(ludiag,
cD    &  '('' Self, before:'',
cD    &  /,'' tri('',i2,'','',i2,'','',i1,'','',i1,'') = '',g18.12,
cD    &  /)')
cD    &  iaid,laid,ktau,iself,
cD    &  tri(iaid,laid,ktau,iself)

                                tri(iaid,laid,ktau,iself) =
     &                            tri(iaid,laid,ktau,iself) +
     &                            dble(error(iaid,jsyn,ktau))

cD     if (iodiag) write(ludiag,
cD    &  '('' Self, after:'',
cD    &  /,'' tri('',i2,'','',i2,'','',i1,'','',i1,'') = '',g18.12,
cD    &  /,'' error('',i2,'','',i3,'','',i1,'') = '',i6,
cD    &  /)')
cD    &  iaid,laid,ktau,iself,
cD    &  tri(iaid,laid,ktau,iself),
cD    &  iaid,jsyn,ktau,
cD    &  error(iaid,jsyn,ktau)

ckpd                            Add the signed value of the "matching"
ckpd                            ERROR(LAID,JSYN,KTAU) to
ckpd                            TRI(IAID,LAID,JSYN,KTAU,iother).

cD     if (iodiag) write(ludiag,
cD    &  '('' Other, before:'',
cD    &  /,'' tri('',i2,'','',i2,'','',i1,'','',i1,'') = '',g18.12,
cD    &  /)')
cD    &  iaid,laid,ktau,iother,
cD    &  tri(iaid,laid,ktau,iother)

                                tri(iaid,laid,ktau,iother) =
     &                            tri(iaid,laid,ktau,iother) +
     &                            error(laid,jsyn,ktau)

cD     if (iodiag) write(ludiag,
cD    &  '('' Other, after:'',
cD    &  /,'' tri('',i2,'','',i2,'','',i1,'','',i1,'') = '',g18.12,
cD    &  /,'' error('',i2,'','',i3,'','',i1,'') = '',i6,
cD    &  /)')
cD    &  iaid,laid,ktau,iother,
cD    &  tri(iaid,laid,ktau,iother),
cD    &  iaid,jsyn,ktau,
cD    &  error(iaid,jsyn,ktau)

ckpd                            Offset the "current" value of
ckpd                            ERROR(IAID,JSYN,KTAU) by program
ckpd                            parameter GAMOFF (see far above) to
ckpd                            avoid taking a log of zero or a negative
ckpd                            value, then add its natural log into
ckpd                            TRI1(IAID,LAID,KTAU,iself).

cD     if (iodiag) write(ludiag,
cD    &  '('' Self, before:'',
cD    &  /,'' tri1('',i2,'','',i2,'','',i1,'','',i1,'') = '',g18.12,
cD    &  /)')
cD    &  iaid,laid,ktau,iself,
cD    &  tri1(iaid,laid,ktau,iself)

                                tri1(iaid,laid,ktau,iself) =
     &                            tri1(iaid,laid,ktau,iself) +
     &                            dlog(dble(error(iaid,jsyn,ktau)) +
     &                            dble(gamoff))

cD     if (iodiag) write(ludiag,
cD    &  '('' Self, after:'',
cD    &  /,'' tri1('',i2,'','',i2,'','',i1,'','',i1,'') = '',g18.12,
cD    &  /,'' error('',i2,'','',i3,'','',i1,'') = '',i6,
cD    &  /,'' gamoff = '',g18.12,
cD    &  /,'' dlog(dble(error(iaid,jsyn,ktau))+dble(gamoff)) = '',g18.12,
cD    &  /)')
cD    &  iaid,laid,ktau,iself,
cD    &  tri1(iaid,laid,ktau,iself),
cD    &  iaid,jsyn,ktau,
cD    &  error(iaid,jsyn,ktau),
cD    &  gamoff,
cD    &  dlog(dble(error(iaid,jsyn,ktau)) +  dble(gamoff))

ckpd                            Offset the "matching" value of
ckpd                            ERROR(LAID,JSYN,KTAU) by program
ckpd                            parameter GAMOFF (see far above) to
ckpd                            avoid taking a log of a zero or negative
ckpd                            value, then add its natural log into
ckpd                            TRI1(IAID,LAID,KTAU,iother).

cD     if (iodiag) write(ludiag,
cD    &  '('' Other, before:'',
cD    &  /,'' tri1('',i2,'','',i2,'','',i1,'','',i1,'') = '',g18.12,
cD    &  /)')
cD    &  iaid,laid,ktau,iother,
cD    &  tri1(iaid,laid,ktau,iother)

                                tri1(iaid,laid,ktau,iother) =
     &                            tri1(iaid,laid,ktau,iother) +
     &                            dlog(dble(error(laid,jsyn,ktau)) +
     &                            dble(GAMOFF))

cD     if (iodiag) write(ludiag,
cD    &  '('' Other, after:'',
cD    &  /,'' tri1('',i2,'','',i2,'','',i1,'','',i1,'') = '',g18.12,
cD    &  /,'' error('',i2,'','',i3,'','',i1,'') = '',i6,
cD    &  /,'' gamoff = '',g15.10,
cD    &  /,'' dlog(dble(error(laid,jsyn,ktau))+dble(gamoff)) = '',g18.12,
cD    &  /)')
cD    &  iaid,laid,ktau,iother,
cD    &  tri1(iaid,laid,ktau,iother),
cD    &  laid,jsyn,ktau,
cD    &  error(laid,jsyn,ktau),
cD    &  gamoff,
cD    &  dlog(dble(error(laid,jsyn,ktau)) +  dble(gamoff))

ckpd                          End Gamma Median case.

ckpd                          Arithmetic Median of Signed Errors:

                              else if (istat .eq. medsgn) then
                              continue

ckpd                          End Arithmetic Median of Signed Errors
ckpd                          case.

ckpd                          Arithmetic Median of Absolute Errors:

                              else if (istat .eq. medabs) then

                              continue

ckpd                          End Arithmetic Median of Absolute Errors
ckpd                          case.

ckpd                          End case ISTAT.

                              endif

ckpd                          bump the occurrence counter
ckpd                          TRI(IAID,LAID,KTAU,koccur) by 1

                              tri(iaid,laid,ktau,koccur) =
     &                          tri(iaid,laid,ktau,koccur) + dble(1.0)

cD     if (iodiag) write(ludiag,
cD    &  '('' after bump, tri('',i2,'','',i2,'','',i1,'','',i1,'') = '',
cD    &  g18.12)') iaid,laid,ktau,koccur,tri(iaid,laid,ktau,koccur)

cD                             if (iodiag)
cD    &                          write(*,'('' bumped '',4i4)')
cD    &                          iaid,laid,ktau,koccur

ckpd                        Endif "no valid [matching or self, depending
ckpd                        on whether on or off hypotenuse subscripts
ckpd                        case] data" entry.

                            endif

ckpd                      End else  LAID >= IAID computations.

                          endif

ckpd                    End for each LAID of the NTUSED requested
ckpd                    techniques.

  570                   continue

ckpd                  End for each KTAU in the 5 possible forecast
ckpd                  offset taus.

  580                 continue

ckpd                End for each JTAU in the NDIF synoptic periods of
ckpd                the storm's life.

  590               continue

ckpd              End for each IAID of the NTUSED requested techniques.

  600             continue

ckpd            Endif LSTDY was modified for this storm.

                endif

cF     if (iodiag)
cF    &  write(*,'('' Exiting filtri()'')')

      return

      end
c-----------------------------------------------------------------------
      subroutine fntech(atech,ltechs,ntech,iodiag)
c-----------------------------------------------------------------------

ckpd  Store the technique names in ntech from the names stored in atech
ckpd  according to the requests flagged in ltechs.  By limitations
ckpd  imposed during prior processing, ltechs contains at most naids
ckpd  .true. components.

      include 'triparms.inc'

      logical*1        ltechs(taids)
      logical*1        iodiag
      character*4      atech(taids)
      character*4      ntech(naids,ntau)

ckpd  jaido  is a counter/index for aids "output" to array ntech

      integer          jaido

ckpd  iaidi  is a counter/index for aids "input" from array atech

      integer          iaidi

ckpd  ktau   is a counter/index for the ntau possible forecast future
ckpd            times for a single synoptic period's forecast for one
ckpd            storm.

      integer          ktau

cF     if (iodiag)
cF    &  write(*,'('' Entering fntech()'')')

      jaido = 1

      do 20 iaidi = 1,taids

        if (ltechs(iaidi)) then

          do 10 ktau=1,ntau

            ntech(jaido,ktau) = atech(iaidi)

   10     continue

cD         if (iodiag)
cD    &      write(*,'('' ntech('',i2,'',*) = '',5(1x,a4))')
cD    &      jaido,(ntech(jaido,ktau),ktau=1,ntau)

          jaido = jaido + 1

        else

          continue

cD         if (iodiag)
cD    &      write(*,'('' Unselected aid: '',a4,1x,l1)')
cD    &      atech(iaidi),ltechs(iaidi)

        endif

   20 continue

cF     if (iodiag)
cF    &  write(*,'('' Exiting fntech()'')')

      return

      end
c-----------------------------------------------------------------------
      function gmamed (sum,sumln,count,iodiag)
c-----------------------------------------------------------------------

ckpd  Find the half-probability point in a gamma function family curve
ckpd  normalized to fit our forecast errors data sample statistics. This
ckpd  is in some sense an approximation of the "median" forecast error.

      include 'triparms.inc'

      integer   gmamed

      real*8    sum
      real*8    sumln
      real*8    count
      logical*1 iodiag

      real*8    oavsum
      real*8    diflog
      real*8    alpha
      real*8    beta
      real*8    astep
      real*8    peak
      real*8    peakl
      real*8    peakr
      real*8    work
      real*8    prob
      real*8    probl
      real*8    probr

      real*8    dgamdf
      external  dgamdf

      integer   ier
      integer   iercd
      external  iercd

      integer   kloop

      real*8    secant
      external  secant

cF     if (iodiag)
cF    &  write(*,'('' Entering gmamed().'')')

cD     if (iodiag)
cD    &  write(ludiag,'('' g probl,probr,peakl,peakr'')')

ckpd  Save a lot of silliness later by setting the return value to the
ckpd  "no data" value to start out.

      gmamed = dble(nodata)

ckpd  If there are at least 10 samples, to make this statistic
ckpd  meaningful, then ...

      if (count .ge. dble(10.0)) then

ckpd    Compute the average (mean) of the signed data, as previously
ckpd    summed into parameter SUM, and offset it the same amount,
ckpd    program parameter GAMOFF, that we offset the data before taking
ckpd    its log as we accumulated the second parameter, SUMLN.

        oavsum = (sum/count) + dble(gamoff)


ckpd    Take the difference between the log of the offset mean of the
ckpd    data and the mean of the logs of the offset data.

        diflog = dlog(oavsum) - sumln/count

ckpd    If the difference of the logs (vaguely) is of the correct sign
ckpd    to continue, do so.

        if (diflog .gt. dble(0.0)) then

ckpd    Compute the shape parameter that picks a certain member of the
ckpd    Gamma Function family of curves.

          beta = ( dble(1.0) + dsqrt(dble(1.0) + 
     &             (diflog *  ( dble(4.0) / dble(3.0) ) ) ) )
     &           / ( dble(4.0) * diflog )

ckpd      If the just computed gamma function family curve shape
ckpd      parameter BETA would allow for a meaningful result for
ckpd      forecast error values' median (it is a curve with a central
ckpd      hump, the way we think our errors data looks, rather than one
ckpd      with a cusp on the left end), then proceed.

ckpd FIXME  Not what the book says:
ckpd          if (beta .gt. dble(1.0)) then

          if (beta .gt. dble(0.0)) then

ckpd        Compute a normalization scaling factor for our peak value
ckpd        estimator.

            alpha = beta/oavsum

ckpd        Set up to do an iterative search for the middle of the
ckpd        probability distribution with the shape parameters we just
ckpd        computed (at least conceptually the "peak" of the "hump"
ckpd        (which we just guaranteed exists by our check on beta) in
ckpd        the Gamma Function probability density curve).  That is,
ckpd        find the point where the gamma function tells us one half of
ckpd        the total probability distribution is to the left of our
ckpd        test point.

ckpd        Our plan is to bracket the target value with PEAKL, the left
ckpd        end of the search interval, and PEAKR, the right end of the
ckpd        search interval, determine the integral of the probability
ckpd        distribution function from zero to each end, and then close
ckpd        in the ends using a secant interpolation until the midpoint
ckpd        (integral = 0.5) of the probability distribution is
ckpd        bracketed between two points less than our intended error
ckpd        for this table, one nautical mile in the units being used.

ckpd        Make a first guess for the left end of the bracketing
ckpd        interval.

            peak = oavsum - dble(3.0) * dsqrt( beta / (alpha * alpha ))

ckpd        Copy it to left interval end PEAKL, for futher use.

            peakl = peak

ckpd        Pick a second point PEAKR for the right end of the interval
ckpd        that is farther away than we ever expect our data midpoint
ckpd        to lie. If we're wrong, we just have to do more work below.

            peakr = peak + astep

ckpd        Check the initialization of the right and left probability
ckpd        distribution value inteval holders.  If they don't bracket
ckpd        the distribution midpoint, try widening them.

ckpd        Scale the left interval end with our normalization scaling
ckpd        factor into a working variable.

            work = peakl * alpha

ckpd        Call the IMSL gamma function with trial value WORK and shape
ckpd        factor BETA, and store the result as the probability
ckpd        integral from zero to WORK in the BETA shaped gamma family
ckpd        function's curve.

            probl = dgamdf(work,beta)

ckpd        Bail out in the case of an error from the IMSL routine.

            ier   = iercd()

            if (ier .ne. 0) then

cD             if (iodiag)
cD    &          write(ludiag,
cD    &          '('' gmamed():  Failed at left initial try: '',
cD    &          3g13.6)') peakl,alpha,beta

              goto 300

            endif

ckpd        Scale the right interval end as above.

            work = peakr * alpha

ckpd        Find the density function integral to the right interval end
ckpd        as above.

            probr = dgamdf(work,beta)

ckpd        Bail out in the case of an error from the IMSL routine.

            ier   = iercd()

            if (ier .ne. 0) then

cD             if (iodiag)
cD    &          write(ludiag,
cD    &          '('' gmamed():  Failed at right initial try: '',
cD    &          3g13.6)') peakr,alpha,beta

              goto 300

            endif

ckpd        Try to bracket the 0.5 value, so that we can use a secant
ckpd        rule (normally quadratically convergent) to speed
ckpd        convergence.

ckpd        If it takes more than ten tries to widen our interval enough
ckpd        to bracket the midpoint, we're probably locked in a loop due
ckpd        to data anomolies, and not going to converge, anyway.

            do 100, kloop = 1,10

cD             if (iodiag)
cD    &          write(ludiag,'('' g '',4g13.6)')
cD    &          probl,probr,peakl,peakr

ckpd          Check whether we truly bracketed the midpoint of the
ckpd          probability distribution with our guesses above.

ckpd          if the left end is left of the center ...

              if (probl .lt. dble(0.5)) then

ckpd            if the right end is right of center ...

                if (probr .gt. dble(0.5)) then

ckpd              Then we're ready, so call our secant routine to do the
ckpd              rest of the computation.

                  goto 200

                else

                  peakr = peakr * dble(2.0)

ckpd              Normalize the estimate to an unscaled gamma function's
ckpd              expected input.

                  work = alpha * peakr

                  probr = dgamdf(work,beta)

                  ier   = iercd()

                  if (ier .ne. 0) then

cD                   if (iodiag)
cD    &                write(ludiag,
cD    &                '('' gmamed():  Failed widening right bracket: '',
cD    &                3g13.6)') peakr,alpha,beta

                    goto 300

                  endif

                endif

              else

                peakl = peakl * dble(0.5)

                work = alpha * peakl

                probl = dgamdf(work,beta)

                ier   = iercd()

                if (ier .ne. 0) then

cD                if (iodiag)
cD    &             write(ludiag,
cD    &               '('' gmamed():  Failed widening left bracket: '',
cD    &               3g13.6)') peakl,alpha,beta

                  goto 300

                endif

              endif

  100       continue

ckpd        If we fall through, the "no data" value set far above gets
ckpd        returned.

            goto 300

ckpd      Else the shape parameter is of a value that corresponds to a
ckpd      positive going cusp in the data curve at the y-axis (x =
ckpd      zero), not the kind of distribution we believe our forecast
ckpd      errors to have, and so not one for which the gamma median is a
ckpd      meaningful statistic, so ...

          endif

ckpd    Else the difference of the logs is negative, probably not a
ckpd    useful result, so ...

ckpd    Endif the difference of the offset logs is unhappily of
ckpd    the wrong sign.

        endif

      endif

      goto 300

ckpd  If we get this far, the mid-distribution value is bracketed
ckpd  by peakl and peakr, so call the secant routine to converge
ckpd  on the value (we hope).

  200 continue

ckpd  -------------------- Here's the secant call ----------------------

      gmamed = secant(probl,probr,peakl,peakr,alpha,beta,iodiag)

  300 continue

cW     if (gmamed .ge. dble(-9998.0)) then

cW       goto 400

cW     else
 
cW       write(ludiag,
cW    &    '('' Gamma median failed, returning "no data" value.'')')

cW     endif

cW 400 continue

cF     if (iodiag)
cF    &  write(*,'('' Exiting gmamed().'')')

ckpd  Return to the calling program, returning as the value of the
ckpd  function the last value assigned to gmamed.

      return

      end
c-----------------------------------------------------------------------
      subroutine opfils(iodiag)
c-----------------------------------------------------------------------

      include 'triparms.inc'

      integer iarg
      logical*1  iodiag
      character*120 techlist,ddeck,control,debug,output
c
c  get arguments from command line
c
cajs  Use the following starting arg # when compiling with f77
cajs      iarg = 1
cajs  Use the following starting arg # when compiling with f90
      iarg = 2
      call getarg(iarg,techlist)
      iarg = iarg + 1
      call getarg(iarg,ddeck)
      iarg = iarg + 1
      call getarg(iarg,control)
      iarg = iarg + 1
      call getarg(iarg,debug)
      iarg = iarg + 1
      call getarg(iarg,output)
      iarg = iarg + 1
c
c  open files
c
cF     if (iodiag)
cF    &  write(*,'('' Entering opfils()'')')

ckpd  Open the technique list, usually techlist.def, the first file name
ckpd  from the command line.

      open(lutech,file=techlist,status='old',err=900)

ckpd  Open the "D-Deck" file, usually Dbbnnyy.DAT or DCOMBO.DAT. where
ckpd  "bbnnyy" is a storm ID composed of basin ID, storm season sequence
ckpd  number, and basin season year number.  This is the second file
ckpd  name from the command line.

      open(luinpt,file=ddeck,status='old',err=910)

ckpd  Open the input error and statistics processing control file; only
ckpd  the first logical variable field of each non-comment line is read.
ckpd  The rest of each line is a comment to identify the line to the
ckpd  user editing changes in the control logical variables.  This is
ckpd  the third file read from the command line.

      open(lucont,file=control,status='old',err=920)

ckpd  Open the diagnostic output file; diagnostic output is controlled by
ckpd  input parameter iodiag whose value is set in the previous file.  This
ckpd  is the fourth file name read in from the command line.

      call openfile( ludiag, debug, 'unknown', ioerror )
      if( ioerror .lt. 0 ) goto 930
cajs      open(ludiag,file=debug,status='unknown',err=930)

ckpd  Open the output triangle table file, usually named Dbbnnyy.TRI or
ckpd  DCOMBO.TRI, the fifth and last file name read in from the command
ckpd  line.

      call openfile( lutria, output, 'unknown', ioerror )
      if( ioerror .lt. 0 ) goto 940
cajs      open(lutria,file=output,status='unknown',err=940)

cF     if (iodiag)
cF    &  write(*,'('' Exiting opfils()'')')

      return

cx900   stop
cx     & ' ***** Unable to open obj. aids technique input control file'
cx910   stop ' ***** Unable to open ddeck input file'
cx920   stop ' ***** Unable to open triangle program input control file'
cx930   stop ' ***** Unable to open output diagnostic file'
cx940   stop ' ***** Unable to open output results file'
  900   continue
        print *,'Unable to open obj. aids technique input control file'
        stop
  910   continue
        print *,'Unable to open ddeck input file'
        stop
  920   continue
        print *,'Unable to open triangle program input control file'
        stop
  930   continue
        print *,'Unable to open output diagnostic file'
        stop
  940   continue
        print *,'Unable to open output results file'
        stop
      end
c-----------------------------------------------------------------------
      subroutine posit(iodiag)
c-----------------------------------------------------------------------

ckpd  Subroutine POSIT() computes and writes a separate table of errors
ckpd  in tropical storm position estimates at the time the CARQ or WRNG
ckpd  card positions are captured as compared to the tropical cyclone
ckpd  position estimates in the best track used as "truth".  Unlike the
ckpd  forecast errors, which get worse with time futureward of the
ckpd  forecast synoptic time, these errors get better with time pastward
ckpd  of the forecast synoptic time, because the storm position
ckpd  estimates get smoothed closer and closer to the final best track's
ckpd  estimates as time passes and forecasters revise the estimates.
ckpd  Because the CARQ estimates are captured at the time the objective
ckpd  aids data request is sent to the site where the meteorological
ckpd  models are run, essentially at the start of the forecast effort,
ckpd  while the WRNG estimates are captured at the end of the forecast
ckpd  effort, about three hours later, when another round of smoothing
ckpd  of the best track has been done by the forecast team, the WRNG
ckpd  errors are on average substantially less than the CARQ errors.

      include 'triparms.inc'

ckpd  It is possible to accumulate eight or nine significant digits into
ckpd  table "poserr", so it should be declared as an array of double
ckpd  precision reals.

      real*8 poserr(npcard,nptaus,npdata)

ckpd      character*80     line

      character*80     line
      character*5      deck
      character*6      storm
      character*4      itech
      logical*1        iodiag

      integer          iaid
      integer          ktau
      integer          lpos
      integer          itau
      integer          ntcard

ckpd  While the input error data read into ERRIN is in fact in i5
ckpd  format, reading it as f5.0 instead into a double precision
ckpd  variable simplifies the programming, since it is fairly promptly
ckpd  squared alone on the right side of an assignment statement, an
ckpd  action which would overflow a two byte integer, and the
ckpd  accumulation of these could easily overflow even a four byte
ckpd  integer.

      real*8           errin
      integer          iktau


ckpd  Add a control for the diagnostic output file's creation.

ckpd  CARQ and WRNG times are now 0, -6, -12, -18, and -24 hours from
ckpd  the forecast time; that is, they look _backward_ at the last five
ckpd  positions forecast (including the "now" position of the best
ckpd  estimate of the storm's position _at the time of the forecast_),
ckpd  protecting that data from later best track smoothing actions.


      integer   cwtaus(nptaus)

      data cwtaus /0, -6, -12, -18, -24/

cF     if (iodiag)
cF    &  write(*,'('' Entering posit()'')')

ckpd  Clear the position error table to double precision real zeros.

      call dzilch (poserr,npcard * nptaus * npdata)

ckpd  Set the input data file to its starting point.

      rewind luinpt

ckpd  If progress reporting is turned on, report input file progress
ckpd  storm by storm.  To start, read the first input data cards until
ckpd  one with a storm id is found, store it in STORM, and back up one
ckpd  record so that the card will be the next one read.

cP     call stm1id(storm,indone,iodiag)

cP     write(*,'(''    Reading position error data for storm '',a6)')
cP    &  storm

ckpd  For each line of input data, accumulate some statistics into three
ckpd  dimensional (card type, retrospective tau index, accumulation
ckpd  type) array poserr if appropriate ...

  200 continue

ckpd    Read the data line to internal array "line".

        read (luinpt,'(a80)',end=500) line

ckpd    If the storm has changed ...

        if (line(pstmid:pstmid+lstmid-1) .ne. storm) then

ckpd    Capture the new storm name, we're done with the old one.

cP         storm = line(pstmid:pstmid+lstmid-1)

cP         write(*,'(''+   Reading position error data for storm '',
cP    &    a6)') storm

        endif

ckpd    If the first five characters of the input line are spaces ...

        if (line(1:5) .eq. '     ') then

ckpd      Do nothing.

          continue

ckpd    Else this card probably has a readable objective aids technique
ckpd    name, so ...

        else

ckpd      Translate the technique name, retrospective forecast hour, and
ckpd      position error value from the internal array "line".

          read (line,'(2x,a4,i3,8x,f5.0)') itech,itau,errin

ckpd      If the position error has the nodata value ...

          if (errin .le. nodata) then

ckpd        Do nothing.

            continue

ckpd      Else it's worth trying to process this card, so ...

          else

ckpd        If the data card is neither a CARQ technique data card nor a
ckpd        WRNG technique data card ...

            if (itech .ne. 'CARQ' .and. itech .ne. 'WRNG') then

ckpd          Do nothing.

              continue

ckpd        Else this must be interesting data for this table, so ...

            else

ckpd          If the error is unusually large ( > bigerr Nautical Miles,
ckpd          where bigerr is defined in the program parameter include
ckpd          file), copy it to the diagnostic file with a warning
ckpd          message.

cW             if (errin .gt. dble(bigerr))
cW    &          write (ludiag,
cW    &          '('' error gt '',f5.0,'' nmi '',/,1x,a80)')
cW    &          bigerr,line

ckpd          Decide if what we have should be accumulated into the CARQ
ckpd          or the WRNG part of the output table.

              ntcard = icarq
              if (itech .eq. 'WRNG') ntcard = iwrng

ckpd          Turn the retrospective tau found on the input data line
ckpd          into a table index between 1 and nptaus.  First, flag the
ckpd          intended index with an invalid value.

              iktau = -1

ckpd          Next, search the data table CWtaus (CARQ WRNG taus) for an
ckpd          entry that matches the retrospective tau in the input data
ckpd          line.

              do 250 ktau = 1,nptaus

ckpd            If we find one, store its index in the table into the
ckpd            index variable.

                if (itau .eq. cwtaus(ktau)) iktau = ktau

  250         continue

ckpd          If we cannot do so ...

              if (iktau .lt. 0) then

ckpd            Warn the user that the retrospective tau value couldn't
ckpd            be matched, but continue doing the processing without
ckpd            this data.

cW               write(ludiag,
cW    &            '('' ***** ERROR ***** invalid forecast hour'',
cW    &            '' in this ddeck line: '',/)')

cW               write(ludiag,'(a80)') line

cW               write(ludiag,
cW    &            '('' Continuing processing, but do not trust'',
cW    &            /,'' position errors until data is fixed.'')')

ckpd          Else we have some good data, so ..

              else

ckpd            Accumulate the sum of the position errors (they are all
ckpd            of positive magnitude by now, since any valid value
ckpd            measures an absolute distance between technique position
ckpd            and best track position) into the first poserr array
ckpd            position for this technique and this retrospective tau
ckpd            index.

                poserr(ntcard,iktau,isumer) =
     &            poserr(ntcard,iktau,isumer) + errin

ckpd            With intentions of computing a standard deviation for
ckpd            the position errors, accumulate the sum of squared
ckpd            errors into the second poserr array position for this
ckpd            technique and this retrospective tau index.

                poserr(ntcard,iktau,issqer) =
     &            poserr(ntcard,iktau,issqer) + errin*errin

ckpd            To support both mean and standard deviation
ckpd            calculations, accumulate a count of valid position
ckpd            errors seen into the third poserr array position for
ckpd            this technique and retrospective tau index.

                poserr(ntcard,iktau,kpoccu) =
     &            poserr(ntcard,iktau,kpoccu) + dble(1.0)

ckpd          Endif we cannot match this retrospective tau ... else we
ckpd          have some good data.

              endif

ckpd        Endif the technique type is wrong then ... else this must be
ckpd        interesting data.

            endif

ckpd      Endif then the position error has the no data value, else ...

          endif

ckpd    Endif ... else the data card is nonblank in the first five
ckpd    characters.

        endif

ckpd  End of doing: for each line of data in the forecast errors input
ckpd  data file, accumulate some statistics.

      goto 200

ckpd  When done accumulating data into array poserr from the forecast
ckpd  error input data file ...

  500 continue

ckpd  If reporting progress, we have been overwriting a line on the
ckpd  screen.  Report the next step.

cP     write(*,'(''   Making accumulated storm error data into''
cP    &  '' printable statistics.'')')

ckpd  For each KTAU of the NPTAUS possible retrospective forecast time
ckpd  second indices into the POSERR array ...

      do 600 ktau = 1,nptaus

ckpd    For each IAID input line types of the NPCARD possible
ckpd    interesting ddeck data card "forecast aid" type (which for this
ckpd    calculation are no such thing, but instead a capture of
ckpd    retrospective forecast positions in the process forecast by
ckpd    forecast of being smoothed toward the final best track
ckpd    positions) first indices into the POSERR array ...

        do 590 iaid = 1,npcard

ckpd      If the number of input data lines for which statistics for
ckpd      this IAID, KTAU, KOPPU combination were accumulated is zero,
ckpd      then ...

          if (poserr(iaid,ktau,kpoccu) .eq. dble(0.0)) then

ckpd        Do nothing.

            continue

ckpd      Otherwise we can use this KPOCCUth entry as a divisior, so ...

          else

ckpd      Replace the ISUMERth sum of the position errors entry for this
ckpd      IAID, KTAU combination in POSERR with the mean of the
ckpd      (absolute) position errors.

          poserr(iaid,ktau,isumer) =
     &      poserr(iaid,ktau,isumer)/poserr(iaid,ktau,kpoccu)

ckpd      Replace the ISSQERth sum of the squared position errors entry
ckpd      for this IAID, KTAU combination in POSERR with the standard
ckpd      deviation (squared errors over occurrences, minus product of
ckpd      mean errors) of the (absolute) position errors.

          poserr(iaid,ktau,issqer) =
     &      sqrt( (  poserr(iaid,ktau,issqer)
     &               /
     &               poserr(iaid,ktau,kpoccu)
     &            )
     &            -
     &            (  poserr(iaid,ktau,isumer)
     &               *
     &               poserr(iaid,ktau,isumer)
     &            )
     &          )

ckpd      Endif we have no data accumulated for this position, else.

          endif

ckpd    End loop on aid types.

  590   continue

ckpd  End loop on retrospective tau indices.

  600 continue

ckpd If reporting progress, mark a progress point.

cP     write(*,'(''   Printing position error statistics table to'',
cP    &  '' output data file.'')')

ckpd MAINTENANCE WARNING:  Formats for the two write statements to unit
ckpd                       "LUTRIA" depend on the value of program
ckpd                       compile time parameter "NPTAUS" declared in
ckpd                       the program parameters include file, but
ckpd                       cannot be completely parameterized with it;
ckpd                       maintain these two formats in parallel with
ckpd                       NPTAUS changes.  Also, note that these are
ckpd                       not the same set of taus as used for
ckpd                       prospective forecasts.  These taus are
ckpd                       retrospective position estimates, and
ckpd                       disagree in hour offsets and offset signs
ckpd                       with the forecast taus.  They agree in number
ckpd                       with the forecast taus only by coincidence
ckpd                       and because the two values occupy the same
ckpd                       number (program compile time parameter NTAU
ckpd                       == program compile time parameter NPTAUS at
ckpd                       this writing) of fields in the same positions
ckpd                       in the CARQ and WRNG input data lines as the
ckpd                       prospective taus do in the other objective
ckpd                       aids' input data lines.

ckpd  Write a header for the data results to the triangle table output
ckpd  logical unit (though this table is not triangular in format, all
ckpd  the other NTAU times NKINDS times NSTATS possible ones are, thus
ckpd  the file's description as "triangle table outputs").

      write (lutria,'(
     &  //,47x,''POSITION ERRORS (N MI)'',
     &  //,32x,''CARQ'',44x,''WRNG'',
     &  //,17x,''00 HR -06 HR -12 HR -18 HR -24 HR'',
     &     15x,''00 HR -06 HR -12 HR -18 HR -24 HR'',
     &  //)')

ckpd  Write the data type labels (means, standard deviations, and cases)
ckpd  and the data values resulting from the above calculations on
ckpd  (probably) NPDATA lines using implicit I/O loops to pull out the
ckpd  required values. [This is required because back in the stone ages
ckpd  of computing, about 1957, the designers of Fortran made a poor
ckpd  choice (in retrospect) (that a terminating newline be the default
ckpd  for each write statement, rather than that no newline be the
ckpd  default and an explicit newline be required to accomplish a
ckpd  carriage return line feed, a much friendlier choice for formatting
ckpd  output data, as subsequent languages have proved), and we're stuck
ckpd  now with the Fortran designers' choice until eternity).

      write (lutria,'(
     &    2x,''MEAN'',11x,5(i3,4x),14x,5(i3,4x),
     &  /,2x,''STD. DEV.'',6x,5(i3,4x),14x,5(i3,4x),
     &  /,2x,''CASES'',10x,5(i3,4x),14x,5(i3,4x))')
     &  (((int(poserr(iaid,ktau,lpos)),
     &  ktau=1,nptaus),iaid=1,npcard),lpos=1,npdata)

cF     if (iodiag)
cF    &  write(*,'('' Exiting posit()'')')

ckpd  Return to the main routine.

      return

      end
c----------------------------------------------------------------------
      subroutine prttri(ntot,ntech,tri,aerr,stdtau,ner,istat,iodiag)
c----------------------------------------------------------------------

      include 'triparms.inc'

      integer       ntot(ntau)
      character*4   ntech(naids,ntau)
      real*8        tri(naids,naids,ntau,ntdata)
      character*31  aerr(nkinds)
      integer       stdtau(ntau)
      integer       istat
      integer       ner

      integer       iaid
      integer       jaid
      integer       ktau
      logical*1     iodiag

ckpd  Print out the triangle for all ntau tau's.

ckpd  For each x-axis and y-axis technique, there are 4 numbers:

ckpd        number of errors               x-axis absolute mean-med

ckpd        y-axis absolute mean-med       abs(y) - abs(x)

ckpd  Print out for the stand dev/ttest is as follows:

ckpd        ttest conf. value              x-axis standard dev

ckpd        y-axis standard dev            abs(y) - abs(x)

cF     if (iodiag)
cF    &  write(*,'('' Entering prttri()'')')

      do 20 ktau = 1,ntau

        if (ntot(ktau) .gt. 0) then

          if (istat .eq. meanab) then

            write (lutria,'(//40x,i3,''-HOUR MEAN '',a31,//)')
     &        stdtau(ktau),aerr(ner)

          else if (istat .eq. studev) then

            write (lutria,'(//40x,i3,''-HOUR STAND. DEV./T-TEST '',
     &        a31,//)') stdtau(ktau),aerr(ner)

          else if (istat .eq. medgam) then

            write (lutria,'(//40x,i3,''-HOUR GAMMA MEDIAN '',a31,//)')
     &        stdtau(ktau),aerr(ner)

          else if (istat .eq. medsgn) then

            continue

          else if (istat .eq. medabs) then

            continue

          endif

ckpd      MAINTENANCE WARNING:  The value of the constant iterator for
ckpd                            the "(a4,7x)" part of the format
ckpd                            strings  in the below two write
ckpd                            statements must equal the value of
ckpd                            parameter NAIDS. Since parameters may
ckpd                            not be used in formats, this must be
ckpd                            maintained in parallel with the
ckpd                            parameter list.

          write (lutria,'(9x,20(a4,7x))')
     &      (ntech(iaid,ktau),iaid=1,ntot(ktau))

          do 10 jaid=1,ntot(ktau)

ckpd      MAINTENANCE WARNING:  The value of the constant iterator for
ckpd                            the "(1x,2i45)" part of the format
ckpd                            strings  in the below two write
ckpd                            statements must equal the value of
ckpd                            parameter NAIDS. Since parameters may
ckpd                            not be used in formats, this must be
ckpd                            maintained in parallel with the
ckpd                            parameter list.

            write (lutria,'(/1x,a4,20(1x,2i5))')
     &        ntech(jaid,ktau),
     &        (nint(tri(iaid,jaid,ktau,koccur)),
     &         nint(tri(iaid,jaid,ktau,iself)),
     &         iaid=1,jaid)

            write (lutria,'(5x,20(1x,2i5))')
     &        (nint(tri(iaid,jaid,ktau,iother)),
     &        iabs(nint(tri(iaid,jaid,ktau,iother))) -
     &        iabs(nint(tri(iaid,jaid,ktau,iself))),
     &        iaid=1,jaid)

   10     continue

        endif

   20 continue

cF     if (iodiag)
cF    &  write(*,'('' Exiting prttri()'')')

      return

      end
c-----------------------------------------------------------------------
      subroutine rdtech(atech,ltechs,ntused,iodiag)
c-----------------------------------------------------------------------

ckpd  Read the objective aids technique control file, which contains
ckpd  integer (0=off, 1=on) control flags for which aids get statistics
ckpd  run for them in the current basin.  If the flag in the third input
ckpd  column is one, add the aid's ASCII name to array ATECH, and set
ckpd  the aid logical "process me" flag in array LTECHS to "true".

      include 'triparms.inc'

      logical*1        ltechs(taids)
      logical*1        iodiag
      character*4      atech(taids)
      integer          ntused
      integer          iaid
      integer          itemp

cF     if (iodiag)
cF    &  write(*,'('' Entering rdtech()'')')

ckpd  Clear logical and character objective aid (technique) ID arrays.

      do 10 iaid=1,taids

        ltechs(iaid) = .false.
        atech(iaid) = '    '

   10 continue

      ntused = 0

      rewind 1

ckpd  Discard the title header line in the objective aids technique
ckpd  file.

      call eatlin(lutech,1,iodiag)

ckpd  Read the technique name and its 0/1 used/unused flag for each
ckpd  technique in the objective aids technique file.

      do 20 iaid = 1,taids

      read (lutech,'(4x,a4,3x,i1)',end=30) atech(iaid),itemp

      if (itemp .eq. 1) then

        ltechs(iaid) = .true.

        ntused = ntused + 1

cD       if (iodiag)
cD    &    write (ludiag,'('' aid '',a4,'' will be processed'')')
cD    &    atech(iaid)

      else

cD       if (iodiag)
cD    &    write (ludiag,'('' aid '',a4,'' will not be processed'')')
cD    &    atech(iaid)

      endif


      if (ntused .gt. naids) ltechs(iaid) = .false.

   20 continue

ckpd  We have a problem if this falls though without an end of file
ckpd  being found, since taids is supposed to slightly exceed the
ckpd  number of legal aids in use.  Ignore the extra but warn the user.

cW     write (*,
cW    &  '('' Unexpectedly found more than the maximum aids lines, '',
cW    &    i3,'','',/,
cW    &    '' that this program was written to expect.  Check the'',
cW    &    '' objective aids technique'',/,
cW    &    '' list file for correctness, and fix it or request program''
cW    &    '' maintenance, as'',/,
cW    &    '' appropriate.  Will ignore excess and continue.'')') taids

   30 close (lutech)


ckpd  We have a less severe problem if the user flagged too many aids
ckpd  for processing in the input objective aids technique list file.
ckpd  Again, ignore the extra and warn the user.

      if (ntused .gt. naids) then

cW       write(*,40) ntused,naids

cW  40   format(' ','**** WARNING ****  ',i2,' techniques',/
cW    &         ' ','were requested in method file. only first',/
cW    &         ' ',i2,' can be used')

        ntused = naids

      endif

cF     if (iodiag)
cF    &  write(*,'('' Exiting rdtech()'')')

      return

      end
c-----------------------------------------------------------------------      
      subroutine remdud(ntot,tri,tri1,ntech,ntused,iodiag)
c-----------------------------------------------------------------------

c  All d deck data has been read. now take out any techniques
c  that have no errors in the given data.

      include 'triparms.inc'

      real*8           tri(naids,naids,ntau,ntdata)

      real*8           tri1(naids,naids,ntau,n1data)

      character*4      ntech(naids,ntau)

      integer          ntot(ntau)

      integer          ntused

      logical*1        iodiag

      integer          kaid

      integer          iaid

      integer          jaid

      integer          ktau

      integer          lpos

cP     logical*1        dudrmd

cF     if (iodiag)
cF    &   write(*,'('' Entering remdud()'')')

cD     if (iodiag) then

cD       write (ludiag,'('' remdud(): entry, NTUSED ='',i6)') ntused

cD     endif

cP     dudrmd = .false.

ckpd FIXME  The error message printouts of the triangle tables at the
ckpd FIXME  entrance and exit of remdud.for are set to a particular
ckpd FIXME  value of ntused = 3.  To be of general use, the program
ckpd FIXME  needs to build a dynamic format line based on ntused and use
ckpd FIXME  it to print the same information.  Four large debug trace
ckpd FIXME  printouts are involved, too expensive of time to do
ckpd FIXME  correctly to just toss out, but implementing the four format
ckpd FIXME  builders needed to make them work in the general case is not
ckpd FIXME  worth the time unless this problem area is revisited often.

ckpd  write(ludiag,'(
ckpd &  '' remdud()  Tri at entry:  '',/,9x,03i18,
ckpd &  05(03(/,2x,i2,1x,i1,1x,i1,1x,03g18.12),/)
ckpd &  )')
ckpd &  (jaid,jaid=1,ntused),
ckpd &  (((iaid,ktau,lpos,(tri(iaid,jaid,ktau,lpos),
ckpd &  jaid=1,ntused),lpos=1,ntdata),iaid=1,ntused),ktau=1,ntau)

ckpd  write(ludiag,'(
ckpd &  '' remdud()  Tri1 at entry:  '',/,9x,03i18,
ckpd &  05(02(/,2x,i2,1x,i1,1x,i1,1x,03g18.12),/)
ckpd &  )')
ckpd &  (jaid,jaid=1,ntused),
ckpd &  (((iaid,ktau,lpos,(tri1(iaid,jaid,ktau,lpos),
ckpd &  jaid=1,ntused),lpos=1,n1data),iaid=1,ntused),ktau=1,ntau)

      do 100 ktau = 1, ntau

        ntot(ktau) = ntused

ckpd  This works much better counted backwards:

        do 90 kaid = ntused,1,-1

          if (tri(kaid,kaid,ktau,koccur) .eq. dble(0.0)) then

ckpd  If progress reporting is compile in, give a compression status
ckpd  report for each aid not used at a tau, whether we actually
ckpd  compress it, or just ignore it.

ckpd  Avoid overwriting the last line printed by some other program.

cP     if (.not. dudrmd) write(*,'(''  '')')

cP     write(*,
cP    & '(''+   Compressing out unused aid '',a4,'' for tau '',i1,
cP    &   ''.'')') ntech(kaid,ktau),ktau

cP     dudrmd = .true.

ckpd  There is no need to move the lines above this line down if this is
ckpd  already the highest-indexed line of valid data, since it gets
ckpd  ignored ever after merely by reducing the value of ntot(ktau) by
ckpd  one. Also, for the original top line, this wouldn't work at all,
ckpd  since the array indices used for the line to be moved down then
ckpd  become invalid.

            if (kaid .lt. ntot(ktau)) then

cD     if (iodiag)
cD    &  write(ludiag,'('' collapsing out row and column '',i6,'' = '',
cD    &  a4)') kaid,ntech(kaid,ktau)

c  Since the number of errors in the hypotenuse is zero for this
c  technique, move the remainder of the triangle 1 line to the
c  left....

              do 40 iaid=kaid,ntot(ktau)-1

                do 30 jaid=kaid,ntot(ktau)

                  do 10 lpos = 1,n1data

                    tri1(iaid,jaid,ktau,lpos) =
     &                tri1(iaid+1,jaid,ktau,lpos)

   10             continue

                  do 20 lpos=1,ntdata

                    tri(iaid,jaid,ktau,lpos) =
     &                tri(iaid + 1,jaid,ktau,lpos)

   20             continue

   30           continue

   40         continue

c  ...and up 1 line.

              do 70 jaid=kaid,ntot(ktau)-1

                do 60 iaid=1,ntot(ktau)-1

                  do 45 lpos = 1,n1data

                    tri1(iaid,jaid,ktau,lpos) =
     &                tri1(iaid,jaid+1,ktau,lpos)

   45             continue

                  do 50 lpos=1,ntdata

                    tri(iaid,jaid,ktau,lpos) =
     &                tri(iaid,jaid+1,ktau,lpos)

   50             continue

   60           continue

   70         continue

c  remove the technique from the list to be printed.

              do 80 iaid=kaid,ntot(ktau) - 1

                ntech(iaid,ktau) = ntech(iaid+1,ktau)

   80         continue

ckpd        Endif there is valid data, above that indexed by kaid, to be
ckpd        moved down.

            endif

c  Bump down ntot, the total number of techniques that will be printed
c  for each tau.

            ntot(ktau) = ntot(ktau) - 1

ckpd      Endif there is no valid data for this aid index.

          endif


   90   continue

cD       if (iodiag)
cD    &  write(*,'('' after remdudding, ntot('',i1,'') = '',i6)')
cD    &  ktau,ntot(ktau)

  100 continue


ckpd  write(ludiag,'(
ckpd &  '' remdud()  Tri at exit:  '',/,9x,03i18,
ckpd &  05(03(/,2x,i2,1x,i1,1x,i1,1x,03g18.12),/)
ckpd &  )')
ckpd &  (jaid,jaid=1,ntused),
ckpd &  (((iaid,ktau,lpos,(tri(iaid,jaid,ktau,lpos),
ckpd &  jaid=1,ntused),lpos=1,ntdata),iaid=1,ntused),ktau=1,ntau)

ckpd  write(ludiag,'(
ckpd &  '' remdud()  Tri1 at exit:  '',/,9x,03i18,
ckpd &  05(02(/,2x,i2,1x,i1,1x,i1,1x,03g18.12),/)
ckpd &  )')
ckpd &  (jaid,jaid=1,ntused),
ckpd &  (((iaid,ktau,lpos,(tri1(iaid,jaid,ktau,lpos),
ckpd &  jaid=1,ntused),lpos=1,n1data),iaid=1,ntused),ktau=1,ntau)


cF     if (iodiag)
cF    &  write(*,'('' Exiting remdud()'')')

      return

      end
c-----------------------------------------------------------------------
      subroutine rerrf(lerror,iodiag)
c-----------------------------------------------------------------------

      include 'triparms.inc'

      logical*1        lerror(nkinds)
      logical*1        iodiag
      integer          kerror

cF     if (iodiag)
cF    &  write(*,'('' Entering rerrf()'')')

c*****        type of errors to analyze

      do 20 kerror=1,nkinds

c  read the user's requested error types

        read(lucont,'(L7)') lerror(kerror)

20    continue

cF     if (iodiag)
cF    &  write(*,'('' Exiting rerrf()'')')

      return

      end
c-----------------------------------------------------------------------
      subroutine rstatf(lstats,iodiag)
c-----------------------------------------------------------------------

ckpd  Read from control file kpdtri.in the flags for the kind of
ckpd  statistics to produce in the output.

      include 'triparms.inc'

      logical*1        lstats(nstats)
      logical*1        iodiag
      integer          kstats


cF     if (iodiag)
cF    &  write(*,'('' Entering rstatf()'')')

      do 100 kstats=1,nstats

        read(lucont,'(L7)',end=900,err=900) lstats(kstats)

  100 continue

cF     if (iodiag)
cF    &  write(*,'('' Exiting rstatf()'')')

      return

  900 continue 
      print *,' program control file short of stats lines or unreadable'
      stop 

      end
c-----------------------------------------------------------------------
      function secant(probl, probr, peakl, peakr, alpha, beta, iodiag)
c-----------------------------------------------------------------------      

ckpd  Use a modified secant rule to speed convergence in the slow gamma
ckpd  median interpolation.

      include 'triparms.inc'

      real*8     secant
      real*8     probl
      real*8     probr
      real*8     peakl
      real*8     peakr
      real*8     alpha
      real*8     dgamdf
      external   dgamdf

      real*8     prob
      real*8     peak
      real*8     work

      real*8     ltemp
      real*8     rtemp
      real*8     ptemp
      real*8     pltemp
      real*8     prtemp
      real*8     dptemp

      integer    ier
      integer    iercd
      external   iercd

      integer    kloop

      logical*1 iodiag
      logical*1 badend

cF     if (iodiag) write(ludiag,'('' Entering secant()'')')

cD     if (iodiag)
cD    &   write(ludiag,'('' s peakl,peak,peakr,probl,prob,probr'')')

ckpd  If we don't converge in 20 tries, give up; five or six is usual.

      do 100 kloop = 1,20

ckpd    Set a logic flag so we can check both ends of the interval for
ckpd    possible special case narrowing.

        badend = .false.

ckpd    Interpolate the new "peak" using a secant interpolation to find
ckpd    a new trial point.

        peak = peakl +
     &    (peakr - peakl)*(dble(0.5) - probl)/(probr - probl)

ckpd    Check for convergence.  The units are nautical miles (NM), and
ckpd    we only keep score in the triangle tables to the whole NM, so
ckpd    one unit is an appropriate size to which to shrink the search
ckpd    interval before deciding we've found the peak.

        if ((peakr - peakl) .le. dble(1.0)) then

cD       if (iodiag)
cD    &  write(ludiag,'('' se '',6g12.7)')
cD    &  peakl,peak,peakr,probl,prob,probr

ckpd      Remove the parameter GAMOFF offset we installed in filtri.for
ckpd      to save us from taking the natural log of a non-positive
ckpd      number.

          secant = peak - dble(gamoff)

ckpd  ----------------- Here is the normal loop exit -------------------

          goto 300

        endif

ckpd    Check for the secant approximation's one horrible habit, moving
ckpd    only one end of the interval even though the other end is
ckpd    massively further from the zero being sought, and continuing to
ckpd    do so until the iteration limit expires, never satisfying the
ckpd    convergence criterion of having the ends close together, while
ckpd    actually finding the zero to dozens of decimal places.

ckpd    Compute a few temporaries to save time later on.

        rtemp = peakr - peak
        ltemp = peak - peakl
        drtemp = probr - prob
        dltemp = prob - probl

ckpd    If the right end of our bracketing interval  is very close to
ckpd    the test point, and distribution integral up to the the right
ckpd    end is very close to the distribution integral up to the current
ckpd    trial "peak", check to see if we can move the other end of the
ckpd    bracketing interval in by a factor of 100 to force both ends of
ckpd    the interval to converge to the desired value, preventing the
ckpd    above problem.

        if (rtemp .lt. dble(0.1)) then
          if (drtemp .lt. dble(0.001)) then
            pltemp = peak - dble(0.01) * (ltemp)
            prob = dgamdf(alpha*pltemp,beta)
            ier = iercd()
            if (ier .ne. 0) goto 200
            if (prob .lt. dble(0.5)) then
              probl = prob
              peakl = pltemp
cD            if (iodiag)
cD    &         write(ludiag,'('' sl '',6g12.7)')
cD    &         peakl,peak,peakr,probl,prob,probr
              badend = .true.
            endif
          endif
        endif


ckpd    Do likewise for the other end, checking for IMSL errors and
ckpd    abandoning the search if any occur.

        if (ltemp .lt. dble(0.1)) then
          if (dltemp .lt. dble(0.001)) then
            prtemp = peak - dble(0.01) * (rtemp)
            prob  = dgamdf(alpha*prtemp,beta)
            ier = iercd()
            if (ier .ne. 0) goto 200
            if (prob .gt. dble(0.5)) then
              probr = prob
              peakr = prtemp
cD             if (iodiag)
cD    &          write(ludiag,'('' sr '',6g12.7)')
cD    &          peakl,peak,peakr,probl,prob,probr
              badend = .true.
            endif
          endif
        endif

ckpd    If we adjusted one or both ends above, go to the end of the loop
ckpd    so that this interval special shrinking action counts as an
ckpd    iteration within the limits to which we want to do iterations.

        if (badend) goto 100

ckpd    Otherwise, we're still cruising along fat dumb and happy, so
ckpd    compute a new trial peak and move on.

        work = peak * alpha

        prob = dgamdf(work,beta)

cD       if (iodiag)
cD    &    write(ludiag,'('' sn '',6g12.7)')
cD    &    peakl,peak,peakr,probl,prob,probr

        ier = iercd()

        if (ier .ne. 0) then

cW         write(ludiag,
cW    &      '('' Giving up on gamma median due to non-zero error'',
cW    &        '' from IMSL function dgamdf().'')')

          secant = dble(nodata)

          goto 300

        endif

ckpd    Move the left end of the search interval to the new "peak" if
ckpd    the probability integral up to peak is less than half the total.

        if (prob .lt. dble(0.5)) then

          probl = prob

          peakl = peak

        else

ckpd      Else, move the right end of the search interval to the new
ckpd      "peak" if the probability integral up to peak is more than
ckpd      half the total.

          if (prob .gt. dble(0.5)) then

            probr = prob

            peakr = peak

          else

ckpd        Else, in that rare case where we hit it dead on, report back
ckpd        the happy news by leaving the loop.

            secant = peak - dble(gamoff)

            goto 300

          endif

        endif

  100 continue

ckpd  Target for error bailouts.

  200 continue

ckpd  If we fell through, or took an error path, return a "no data"
ckpd  value.

      secant = dble(nodata)

ckpd  We come straight here if we successfully converged, so this is
ckpd  just a place to put a debug trace before returning.

  300 continue

cF     if (iodiag) write(ludiag,'('' Exiting secant()'')')

      return

      end
c-----------------------------------------------------------------------
      subroutine stm1id(storm,indone,iodiag)
c-----------------------------------------------------------------------

      include 'triparms.inc'

      character*6  storm
      logical*1    indone
      logical*1    iodiag

ckpd  line holds the input files data "cards" when we read them.

      character*80 line
      
cF     if (iodiag)
cF    &  write(*,'('' Entering stm1id()'')')

ckpd  Read the next available storm id off a card that has one.

   10 continue

      read (luinpt,'(a80)',end=900) line

      storm = line(pstmid:pstmid+lstmid-1)

      if (storm .eq. '      ') goto 10

ckpd  We want to see this card again in the normal processing:

      backspace luinpt

      return

900   continue

cW     write(ludiag,
cW    &  '('' Got a new or first storm, and more lines'',/,
cW    &  '' remained in the input ddeck data file, but there'',/,
cW    &  '' were no more lines with a storm id on them.'')')

      indone = .true.

cF     if (iodiag)
cF    &  write(*,'('' Exiting stm1id()'')')

      return

      end
c-----------------------------------------------------------------------
      subroutine ttest (
     & slfmse,othmse,slfkoc,othkoc,slfdev,othdev,qval,ier,iodiag)
c-----------------------------------------------------------------------

ckpd  Subroutine to figure the ttest (Student's T) confidence value,
ckpd  uses the IMSL tdf subroutine.

ckpd  We are trying to figure out if errors from two error
ckpd  distributions differ enough from one another that the
ckpd  difference should not have occurred by chance.

ckpd  The returned result is the probability that the hypothesis
ckpd  "these two samples sampled the same underlying normal
ckpd  distribution, and differ only due to sampling error" is
ckpd  rejectable.


ckpd  Inputs:

ckpd    slfmse - "Self" mean standard error of the forecasting error
ckpd    distribution currently being tested.

ckpd    othmse - "Other" mean standard error of the forecasting
ckpd    error distribution whose underlying normal distribution's
ckpd    identity to that of the current one is in question.

ckpd    slfkoc - Number of samples in the "self" distribution.

ckpd    othkoc - Number of samples in the "other" distribution.

ckpd    slfdev - Standard deviation of the "self" distribution.

ckpd    othdev - Standard deviation of the "other" distribution.


ckpd  Outputs:

ckpd    qval - The probability that the two samples sample the same
ckpd           distribution.

ckpd    ier  - holds the IMSL statistics package common error return
ckpd           from subroutine iercd(); 0 == OK, 5 == Terminal error,
ckpd           2 and down probably close to the right answer.


ckpd  Work variables:

ckpd    dnumer - proportioning constant for the difference of the
ckpd             mean square errors.

ckpd    hypoth - variable for which the hypothesis is being tested
ckpd             that a difference between the proportioned mean
ckpd             square errors which was that large, occurred by
ckpd             chance.

ckpd    dfd    - the sum of the degrees of freedom of the two
ckpd             distributions, reduced by one each because the mean
ckpd             of each of the the real underlying distributions is
ckpd             a hidden variable that removes one degree of
ckpd             freedom.

      real*8    slfmse
      real*8    othmse
      real*8    slfkoc
      real*8    othkoc
      real*8    slfdev
      real*8    othdev
      real*8    qval
      real*8    dfd
      real*8    dnumer
      real*8    hypoth
      real*8    dtdf

      logical*1 iodiag


ckpd  Microsoft Fortran compiler dying here, too.

      real*8    stemp
      real*8    ttemp
      real*8    utemp
      real*8    vtemp
      real*8    wtemp
      real*8    xtemp
      real*8    ytemp
      real*8    ztemp

ckpd  MAINTENANCE WARNING:  The following three declarations cleared up
ckpd                        a program bug that required eight hours of
ckpd                        testing (with a long set of data that, by
ckpd                        good fortune, evoked the error repeatably)
ckpd                        to debug. Though it is undocumented in the
ckpd                        IMSL documentation that it returns an
ckpd                        specific size of integer, the IERCD()
ckpd                        library object module returns explicitly an
ckpd                        integer*4 result. Since this suite of
ckpd                        software is compiled with default two byte
ckpd                        integers, the net result of using default
ckpd                        integer declarations was that the IMSL
ckpd                        routine stacked four bytes and this routine
ckpd                        removed only two of them. Eventually, the
ckpd                        continued corruption of the stack caused a
ckpd                        hard crash, usually fairly remote in the
ckpd                        code from its cause, that required a system
ckpd                        poweer off and on to reset.  As of this
ckpd                        typing, _all_ variables in this triangle
ckpd                        routine are explicitly declared. Lesson
ckpd                        learned!

      integer   ier
      integer   iercd
      external iercd

      external dtdf

cF     if (iodiag)
cF    &  write(*,'('' Entering ttest()'')')

      slfkoc = slfkoc * 0.25

      othkoc = othkoc * 0.25

ckpd FIXME  Microsoft Fortran 4.1 choked again:
ckpd FIXME CONTEXT      d = (
ckpd FIXME CONTEXT     &     (((slfkoc * slfdev * slfdev) +
ckpd FIXME CONTEXT     &       (othkoc * othdev * othdev)) *
ckpd FIXME CONTEXT     &      ((1. / slfkoc) + (1. / othkoc))) /
ckpd FIXME CONTEXT     &     (slfkoc + othkoc - 2.0)
ckpd FIXME CONTEXT     &    )

      stemp  = (slfkoc * slfdev * slfdev)
      ttemp  = (othkoc * othdev * othdev)
      utemp  = (1. / slfkoc)
      vtemp  = (1. / othkoc)
      wtemp  = (slfkoc + othkoc - 2.0)
      xtemp  = stemp + ttemp
      ytemp  = utemp + vtemp
      ztemp  = xtemp * ytemp
      dnumer = ztemp / wtemp

      hypoth = (slfmse-othmse) / sqrt(dnumer)

          hypoth = abs(hypoth)

      dfd = slfkoc + othkoc - 2.0

ckpd  We need double precision reals to compute most of these values,
ckpd  because it is quite possible for a sum of squared errors value to
ckpd  have eight significant digits when a set of forecasts has > 1000
ckpd  Nautical Mile errors (rare, but at least one a year seems to be
ckpd  this hard to forecast).  Therefore we call the double precision
ckpd  version of the IMSL "tdf" routine, "dtdf".

      qval = 2.0 * dtdf(-hypoth,dfd)

          ier = iercd()

cF     if (iodiag)
cF    &  write(*,'('' Exiting ttest()'')')

      return

      end
